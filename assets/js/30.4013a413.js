(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{2340:function(t,s,e){t.exports=e.p+"assets/img/1675213974652.c56d10df.png"},2341:function(t,s,e){t.exports=e.p+"assets/img/1675214090529.7681cf44.png"},2342:function(t,s,e){t.exports=e.p+"assets/img/1675214447531.581f01fe.png"},2343:function(t,s,e){t.exports=e.p+"assets/img/1675214644928.d153a805.png"},2344:function(t,s,e){t.exports=e.p+"assets/img/1675214722265.3cec30a9.png"},2345:function(t,s,e){t.exports=e.p+"assets/img/1675214864517.d03bd20d.png"},2346:function(t,s,e){t.exports=e.p+"assets/img/1675215355693.dd7515cf.png"},2347:function(t,s,e){t.exports=e.p+"assets/img/1675215515762.9d17e44a.png"},2348:function(t,s,e){t.exports=e.p+"assets/img/1675215951068.f38803d9.png"},2349:function(t,s,e){t.exports=e.p+"assets/img/1675216171127.015b5a02.png"},2350:function(t,s,e){t.exports=e.p+"assets/img/1675216186006.75609b58.png"},2351:function(t,s,e){t.exports=e.p+"assets/img/1675217665707.baa07443.png"},2352:function(t,s,e){t.exports=e.p+"assets/img/1675217751176.6a73b35c.png"},2353:function(t,s,e){t.exports=e.p+"assets/img/1675217859243.baff2676.png"},2354:function(t,s,e){t.exports=e.p+"assets/img/1675218153932.e10d7ae1.png"},2355:function(t,s,e){t.exports=e.p+"assets/img/1675218384742.8277769b.png"},2356:function(t,s,e){t.exports=e.p+"assets/img/1675218546959.99df459e.png"},2357:function(t,s,e){t.exports=e.p+"assets/img/1675218813251.2323efaf.png"},2358:function(t,s,e){t.exports=e.p+"assets/img/1675218964887.98875f8b.png"},2359:function(t,s,e){t.exports=e.p+"assets/img/1675219420275.c244deda.png"},2360:function(t,s,e){t.exports=e.p+"assets/img/1675221332401.04dca9a1.png"},2361:function(t,s,e){t.exports=e.p+"assets/img/1675221446044.49fed8b5.png"},2362:function(t,s,e){t.exports=e.p+"assets/img/1675221524736.f17553a0.png"},2363:function(t,s,e){t.exports=e.p+"assets/img/1675222166690.afe13023.png"},2364:function(t,s,e){t.exports=e.p+"assets/img/1675222243891.c94eacc3.png"},6009:function(t,s,e){"use strict";e.r(s);var a=e(15),n=Object(a.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"一-类组件的生命周期-非常重要"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一-类组件的生命周期-非常重要"}},[t._v("#")]),t._v(" 一，类组件的生命周期（非常重要）")]),t._v(" "),a("h3",{attrs:{id:"_1-constructor-装载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-constructor-装载"}},[t._v("#")]),t._v(" 1，constructor(装载)")]),t._v(" "),a("p",[t._v("vue组件的生命周期，有些并不重要，基本上用不到，但是React的生命周期都非常重要，没有多余的，关于生命周期有非常多的面试题。")]),t._v(" "),a("p",[t._v("只有类组件才会有生命周期钩子函数，函数式组件没有生命周期钩子的函数的。")]),t._v(" "),a("p",[t._v("生命周期函数很多，我们需要掌握6个：")]),t._v(" "),a("ul",[a("li",[t._v("装载阶段（3个）：constructor, render, componentDidMount")]),t._v(" "),a("li",[t._v("更新阶段（2个）：render，componentDidUpdate")]),t._v(" "),a("li",[t._v("卸载阶段（1个）：componentWillUnmount")])]),t._v(" "),a("p",[t._v("图示：")]),t._v(" "),a("p",[a("img",{attrs:{src:e(2340),alt:"1675213974652"}})]),t._v(" "),a("p",[a("img",{attrs:{src:e(2341),alt:"1675214090529"}})]),t._v(" "),a("p",[t._v("现在就一个个学习，先学习constructor，代码如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:e(2342),alt:"1675214447531"}})]),t._v(" "),a("p",[t._v("在constructor中，可以完全this的绑定如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:e(2343),alt:"1675214644928"}})]),t._v(" "),a("p",[t._v("昨天我们说了两种解决办法：")]),t._v(" "),a("p",[a("img",{attrs:{src:e(2344),alt:"1675214722265"}})]),t._v(" "),a("p",[t._v("在官方文档中，还有一种解决办法，就是在constructor中进行this绑定，如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:e(2345),alt:"1675214864517"}})]),t._v(" "),a("p",[t._v("在constructor中有一个props，这个props是用来接收父传递的数据的，props的数据流和state的数据流必须独立。下面的代码是不规范的，如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:e(2346),alt:"1675215355693"}})]),t._v(" "),a("p",[t._v("在constructor中，不能调用setState方法，如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:e(2347),alt:"1675215515762"}})]),t._v(" "),a("p",[t._v("在constructor中，不能调用接口，不能进行DOM操作，不能开定时器...  一切和业务相关的代码都不能写在constructor钩子函数中。")]),t._v(" "),a("p",[t._v("总结在constructor中，可以做什么：")]),t._v(" "),a("ul",[a("li",[t._v("定义状态")]),t._v(" "),a("li",[t._v("绑定方法的this")])]),t._v(" "),a("h3",{attrs:{id:"_2-render-装载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-render-装载"}},[t._v("#")]),t._v(" 2，render(装载)")]),t._v(" "),a("p",[t._v("作用：用于返回组件的视图结构，这个结构在vue叫模板，在react中叫jsx。它的背后是生成一棵Fiber树，在vue中叫虚拟DOM，在React叫Fiber树，早期的React也是使用的虚拟DOM。")]),t._v(" "),a("p",[t._v("在render函数中，不能调用setState，如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:e(2348),alt:"1675215951068"}})]),t._v(" "),a("p",[t._v("上面的写法是，你直接调用了setState，有时候，你会间接地调用setState，如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:e(2349),alt:"1675216171127"}})]),t._v(" "),a("p",[t._v("浏览器死循环了，如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:e(2350),alt:"1675216186006"}})]),t._v(" "),a("p",[t._v("render是一个函数，这个函数返回一个jsx，jsx叫jsx元素，本质是一个对象，创建jsx元素有2种方法，一种是直接使用jsx，另外一种是React.creeateEleement。也就说，调用render函数，会生成棵Fiber树，类似于Vue中的虚拟DOM，这个Fiber树是双向链表结构。生成这课Fiber树的过程是异步的，生成的过程是可以中断，能不能中断是看浏览器忙不忙，如果浏览器比较忙，就可能中断，等待浏览器不忙时，会继续生成，直到Fiber树创建完成。然后会进行协调运算，这个协调运算类似于Vue中的Diff运算，也就是一棵老的Fiber树和一棵新的Fiber树进行对比运算。运算对比后，就会进入到commmit提交阶段，一次性提交Fiber更新DOM。")]),t._v(" "),a("h3",{attrs:{id:"_3-componentdidmount-装载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-componentdidmount-装载"}},[t._v("#")]),t._v(" 3，componentDidMount(装载)")]),t._v(" "),a("p",[t._v("类似于vue中的mounted，表示页面第一次渲染完成。在这个钩子函数中可以做什么？")]),t._v(" "),a("ul",[a("li",[t._v("调用接口")]),t._v(" "),a("li",[t._v("开定时器")]),t._v(" "),a("li",[t._v("DOM操作")]),t._v(" "),a("li",[t._v("编写业务逻辑")])]),t._v(" "),a("p",[t._v("代码如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:e(2351),alt:"1675217665707"}})]),t._v(" "),a("h3",{attrs:{id:"_4-render-更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-render-更新"}},[t._v("#")]),t._v(" 4，render(更新)")]),t._v(" "),a("p",[t._v("什么时候进入到更新阶段，如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:e(2352),alt:"1675217751176"}})]),t._v(" "),a("p",[t._v("代码如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:e(2353),alt:"1675217859243"}})]),t._v(" "),a("h3",{attrs:{id:"_5-componentdidupdate-更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-componentdidupdate-更新"}},[t._v("#")]),t._v(" 5，componentDidUpdate(更新)")]),t._v(" "),a("p",[t._v("相当于Vue中的updated，表示页面再次渲染成功。")]),t._v(" "),a("p",[t._v("监听器是用来监听数据是否变化，updated表示数据变化了，会执行updated，也就是说数据变化了，在updated也可以监听到了。要监听数据变化，在vue中，使用监听器比使用updated更方便。在react中是没有监听器的概念的，在React中实现类似于Vue的监听器的功能，需要使用compoentDidUpdate钩子函数了。")]),t._v(" "),a("p",[t._v("上代码：")]),t._v(" "),a("p",[a("img",{attrs:{src:e(2354),alt:"1675218153932"}})]),t._v(" "),a("p",[t._v("如果不使用componentDidUpdate，还有没有办法实现类似于Vue中的监听器？")]),t._v(" "),a("p",[t._v("答：this.setState({}/fn, callback)  利用callback也可以感知到数据变化了。推荐使用componentDidUpdate。因为多个setState会合并，合并后，callback也会出问题。代码如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:e(2355),alt:"1675218384742"}})]),t._v(" "),a("p",[t._v("在componetDidUpdate中，尝试调用setState，如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:e(2356),alt:"1675218546959"}})]),t._v(" "),a("p",[t._v("你要想在componentDidUpdate中调用setState，需要给出一个出口，不给出口，直接爆栈了，给出出口，如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:e(2357),alt:"1675218813251"}})]),t._v(" "),a("p",[t._v("使用定时器把setState包起来如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:e(2358),alt:"1675218964887"}})]),t._v(" "),a("p",[t._v("强调一下，React实现Vue中的监听器。Vue听监听器写法如下：")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("watch")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("page")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        axios"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("then")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("res")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("list "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" res"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("list"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n在Vue中如果不使用watch"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 可以使用updated代替。 但是在React没有watch， 只能使用componentDidUpdate来实现， 或使用setState中的callback来实现。\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br")])]),a("p",[t._v("num变化了，我需要监听到num变化了，如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:e(2359),alt:"1675219420275"}})]),t._v(" "),a("p",[t._v("总结：")]),t._v(" "),a("ul",[a("li",[t._v("componentDidUpdate中可以调用setState，但是必须给出出口（终止条件），否则会产生死循环，循环到一定次数就会报错。")]),t._v(" "),a("li",[t._v("componentDidUpdate可以模拟vue中的监听器，特别需要注意终止条件。")]),t._v(" "),a("li",[t._v("除了使用componentDidUpdate实现监听器之外，还可以使用this.setState中的callback来实现，不建议使用，因为setState会合并，callback容易出问题。")])]),t._v(" "),a("h3",{attrs:{id:"_6-componentwillunmount-卸载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-componentwillunmount-卸载"}},[t._v("#")]),t._v(" 6，componentWillUnmount(卸载)")]),t._v(" "),a("p",[t._v("类似于Vue中的beforeDestroy，表示组件即将销毁。在这里我们可以：")]),t._v(" "),a("ul",[a("li",[t._v("清缓存")]),t._v(" "),a("li",[t._v("清除定时器")]),t._v(" "),a("li",[t._v("关闭长连接")]),t._v(" "),a("li",[t._v("销毁DOM元素")]),t._v(" "),a("li",[t._v("....")])]),t._v(" "),a("h3",{attrs:{id:"_7-shouldcomponentupdate-了解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-shouldcomponentupdate-了解"}},[t._v("#")]),t._v(" 7，shouldComponentUpdate(了解)")]),t._v(" "),a("p",[t._v("它是控制更新阶段的开关，说白了，就是来控制是否更新，当返回true就正常更新，当返回false时就不更新。")]),t._v(" "),a("p",[t._v("在项目中用的不多，是官方提供的一种性能优化方案。")]),t._v(" "),a("p",[a("img",{attrs:{src:e(2360),alt:"1675221332401"}})]),t._v(" "),a("p",[t._v("代码如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:e(2361),alt:"1675221446044"}})]),t._v(" "),a("p",[t._v("默认情况下，没有写的话，就是返回true，看一下state参数，如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:e(2362),alt:"1675221524736"}})]),t._v(" "),a("p",[t._v("shouldComponentUpdate，返回true时，正常更新，返回false时，不执行更新阶段。注意细:")]),t._v(" "),a("ul",[a("li",[t._v("当执行forceUpdate时，会绕过shouldComponentUpdate方法，一定会进入到更新阶段。")]),t._v(" "),a("li",[t._v("shouldComponentUpdate，可以使用PureCompoentf替代")])]),t._v(" "),a("p",[a("img",{attrs:{src:e(2363),alt:"1675222166690"}})]),t._v(" "),a("p",[t._v("为什么要使用这个开关呢？")]),t._v(" "),a("p",[t._v("答：组件中有很多状态，有些状态会参与到界面刷新，也就是说有些状态变了，需要更新页面。但是还有一些状态是不参与到界面更新，也就是状态变了，不需要更新页面的，此时就体现出开关的重要性了。参与页面更新的状态，状态变化了，在showCompoentUpdate中返回true，正常更新。如果没有参与页面刷新的状态变化了，在shouldCompoentUpdate中返回false，就需要再次调用render。这样，就会少生成一次Fiber树。这个钩子函数是用来性能调优的，可以阻塞掉那些不参与视图渲染的状态更新导致的Fiber生成。")]),t._v(" "),a("p",[t._v("React组件渲染（更新）流程，由两个阶段组成的，一个叫render阶段，一个叫commit阶段，如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:e(2364),alt:"1675222243891"}})]),t._v(" "),a("p",[t._v("render阶段：")]),t._v(" "),a("ul",[a("li",[t._v("目标是生成Fiber树，这个过程是异步的，是可中断，并且不会执行任何副作用。到底中断与否，看的是浏览器主线程的忙不忙。")])]),t._v(" "),a("p",[t._v("commit阶段：")]),t._v(" "),a("ul",[a("li",[t._v("目的是把协调运算的结果，一次性提交渲染或更新真实DOM。这个过程在V18之前是不可中断的，在V18中是可以人为中断的。")])])])}),[],!1,null,null,null);s.default=n.exports}}]);