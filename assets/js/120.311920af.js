(window.webpackJsonp=window.webpackJsonp||[]).push([[120],{5855:function(_,v,e){_.exports=e.p+"assets/img/image-20210223093430679.ba3449f9.png"},5856:function(_,v,e){_.exports=e.p+"assets/img/image-20210223103127034.d1867d36.png"},5857:function(_,v,e){_.exports=e.p+"assets/img/image-20210223104924017.657463d9.png"},6219:function(_,v,e){"use strict";e.r(v);var t=e(15),o=Object(t.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"react"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[_._v("#")]),_._v(" React")]),_._v(" "),t("h2",{attrs:{id:"_1-react最新的生命周期是怎么样的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-react最新的生命周期是怎么样的"}},[_._v("#")]),_._v(" 1. React最新的生命周期是怎么样的？")]),_._v(" "),t("p",[_._v("在 React 16 版本中，三个之前的生命周期被标识为废弃，并在 React 17 中计划全部删除它们：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("componentWillMount")])]),_._v(" "),t("li",[t("p",[_._v("componentWillReceiveProps")])]),_._v(" "),t("li",[t("p",[_._v("componentWillUpdate")])])]),_._v(" "),t("p",[_._v("当它们被删除后，将会只保留三个添加了"),t("code",[_._v("UNSAVE_")]),_._v("前缀的函数版本，作为向下兼容用途。因此我们在新项目中，要尽量避免使用这几个生命周期而使用最新的生命周期函数。")]),_._v(" "),t("p",[_._v("⽬前 React 16.8+ 的⽣命周期分为三个阶段：挂载阶段、更新阶段、卸载阶段。")]),_._v(" "),t("p",[t("strong",[_._v("挂载阶段")])]),_._v(" "),t("p",[t("code",[_._v("constructor")]),_._v(" ：组件的构造函数，它会最先被执⾏，我们通常在构造函数⾥初始化 "),t("code",[_._v("state")]),_._v(" 状态对象、或给⾃定义⽅法绑定 "),t("code",[_._v("this")])]),_._v(" "),t("p",[t("code",[_._v("getDerivedStateFromProps")]),_._v(" ：这是个静态⽅法，当我们接收到新的属性后想要去修改 "),t("code",[_._v("state")]),_._v(" 时可以使用")]),_._v(" "),t("p",[t("code",[_._v("render")]),_._v("：这是个只返回需要渲染内容的纯函数，不要包含其它的业务逻辑，可以返回原⽣的 DOM、React 组件、Fragment、Portals、字符串和数字、Boolean 值 和 null 值等内容")]),_._v(" "),t("p",[t("code",[_._v("componentDidMount")]),_._v(" ：在组件装载后被调⽤，此时可以获取 DOM 节点并操作，对服务器的请求、订阅等操作都可以写在这个地方，但记得要在 "),t("code",[_._v("componentWillUnmount")]),_._v(" 中取消订阅，即释放资源")]),_._v(" "),t("p",[t("strong",[_._v("更新阶段")])]),_._v(" "),t("p",[t("code",[_._v("getDerivedStateFromProps")]),_._v(" ：此⽅法在更新个挂载阶段都可能会调⽤")]),_._v(" "),t("p",[t("code",[_._v("shouldComponentUpdate")]),_._v(" ：该函数有两个参数 "),t("code",[_._v("nextProps")]),_._v(" 和 "),t("code",[_._v("nextState")]),_._v("，表示新的属性和变化之后的状态；它返回⼀个布尔值，"),t("code",[_._v("true")]),_._v(" 表示会触发重新渲染，"),t("code",[_._v("false")]),_._v(" 则表示不会触发重新渲染，默认返回 "),t("code",[_._v("true")]),_._v("。我们通常利⽤该⽣命周期来优化 React 程序的性能")]),_._v(" "),t("p",[t("code",[_._v("render")]),_._v(" ：更新阶段也会触发此⽣命周期")]),_._v(" "),t("p",[t("code",[_._v("getSnapshotBeforeUpdate")]),_._v(" ：该⽅法在 "),t("code",[_._v("render")]),_._v(" 之后、在 "),t("code",[_._v("componentDidUpdate")]),_._v(" 之前被调⽤，它有两个参数 "),t("code",[_._v("prevProps")]),_._v(" 和"),t("code",[_._v("prevState")]),_._v("，表示之前的属性和状态，并且该函数有⼀个返回值，返回值会作为第三个参数传给 "),t("code",[_._v("componentDidUpdate")]),_._v(" ，如果不想要返回值则返回 "),t("code",[_._v("null")]),_._v(" 即可。该⽣命周期必须与 "),t("code",[_._v("componentDidUpdate")]),_._v(" 搭配使⽤")]),_._v(" "),t("p",[t("code",[_._v("componentDidUpdate")]),_._v(" ：该⽅法在 "),t("code",[_._v("getSnapshotBeforeUpdate")]),_._v(" ⽅法之后被调⽤，它有三个参数 "),t("code",[_._v("prevProps")]),_._v(" 、"),t("code",[_._v("prevState")]),_._v(" 、"),t("code",[_._v("snapshot")]),_._v(" ，表示之前的属性、之前的状态、以及"),t("code",[_._v("snapshot")]),_._v("。第三个参数是 "),t("code",[_._v("getSnapshotBeforeUpdate")]),_._v(" 所返回的，如果触发某些回调函数时需要⽤到 DOM 元素的状态，则将对⽐或计算的过程迁移⾄ "),t("code",[_._v("getSnapshotBeforeUpdate")]),_._v("，然后在 "),t("code",[_._v("componentDidUpdate")]),_._v(" 中统⼀触发回调或更新状态")]),_._v(" "),t("p",[t("strong",[_._v("卸载阶段")])]),_._v(" "),t("p",[t("code",[_._v("componentWillUnmount")]),_._v(" ：当组件被卸载或销毁时就会被调⽤，我们可以在这个函数⾥去做一些释放资源的操作，如：清除定时器、取消⽹络请求、清理⽆效的 DOM 元素等")]),_._v(" "),t("p",[t("a",{attrs:{href:"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/",target:"_blank",rel:"noopener noreferrer"}},[_._v("React生命周期图形示意工具"),t("OutboundLink")],1)]),_._v(" "),t("h2",{attrs:{id:"_2-在react中网络请求应该放在哪个生命周期中发起"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-在react中网络请求应该放在哪个生命周期中发起"}},[_._v("#")]),_._v(" 2. 在React中网络请求应该放在哪个生命周期中发起？")]),_._v(" "),t("p",[_._v("有人认为 React 中的网络异步请求，应该放在 "),t("code",[_._v("componentWillMount")]),_._v(" 这个生命周期函数中发起，这样可以提前进⾏异步请求，以避免⽩屏现象。其实这个观点是有问题的。")]),_._v(" "),t("p",[_._v("由于 JavaScript 中异步事件的性质，当进行异步 API 调⽤时，浏览器会在此期间继续执⾏其他⼯作。因此，当 React 渲染⼀个组件时，它并不会等待 "),t("code",[_._v("componentWillMount")]),_._v(" 执行完成任何事情，而是继续往前执行并继续做 "),t("code",[_._v("render")]),_._v(" ，没有办法 “暂停” 渲染以等待远程数据的返回。")]),_._v(" "),t("p",[_._v("⽽且，在 "),t("code",[_._v("componentWillMount")]),_._v(" 中发起请求会存在⼀系列潜在问题：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("在用 React 作为服务器渲染（SSR）时，如果在 "),t("code",[_._v("componentWillMount")]),_._v(" 中进行数据的获取，则 "),t("code",[_._v("fetch data")]),_._v(" 会执⾏两次：⼀次在服务端，⼀次在客户端，这就造成了多余的请求")])]),_._v(" "),t("li",[t("p",[_._v("在 React 16 使用 React Fiber 架构重写后，"),t("code",[_._v("componentWillMount")]),_._v(" 可能会在⼀次渲染中被多次调⽤。")])])]),_._v(" "),t("p",[t("strong",[_._v("⽬前官⽅推荐的是在 "),t("code",[_._v("componentDidmount")]),_._v(" 中进行异步请求。")])]),_._v(" "),t("p",[_._v("如遇到特殊需求，需要提前进行数据的请求，可考虑采用在 "),t("code",[_._v("constructor")]),_._v(" 中进行。")]),_._v(" "),t("p",[_._v("另外，由于在 React 17 之后 "),t("code",[_._v("componentWillMount")]),_._v(" 被废弃仅保留 "),t("code",[_._v("UNSAFE_componentWillMount")]),_._v("，所以要慎用该生命周期。")]),_._v(" "),t("h2",{attrs:{id:"_3-setstate是同步的还是异步的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-setstate是同步的还是异步的"}},[_._v("#")]),_._v(" 3. setState是同步的还是异步的？")]),_._v(" "),t("p",[_._v("答案是：有时表现出异步，有时表现出同步！")]),_._v(" "),t("ul",[t("li",[_._v("在合成事件和生命周期钩⼦函数中是异步的")]),_._v(" "),t("li",[_._v("在原⽣事件和 "),t("code",[_._v("setTimeout")]),_._v(" 中是同步的")])]),_._v(" "),t("p",[t("code",[_._v("setState")]),_._v(" 的异步并不是指内部由异步代码实现。其实，它本身执⾏的过程及代码都是同步的，只是由于合成事件和钩⼦函数的调⽤顺序在更新之前，因此导致了在合成事件和钩⼦函数中没法立刻拿到更新后的值，所以形成了所谓的异步。")]),_._v(" "),t("p",[_._v("当然，我们可以通过使用第⼆个参数来拿到更新后的结果，它是个回调函数：")]),_._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[_._v("setState")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),_._v("partialState"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" callback"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v("\n")])]),_._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[_._v("1")]),t("br")])]),t("p",[_._v("此外，"),t("code",[_._v("setState")]),_._v(" 的批量更新优化也是建⽴在异步（合成事件、钩⼦函数）之上的，在原⽣事件和 "),t("code",[_._v("setTimeout")]),_._v(" 中不会批量更新。在异步中，如果对同⼀个值进⾏多次 "),t("code",[_._v("setState")]),_._v("，则它的批量更新策略会对其进⾏覆盖，只取最后⼀次的执⾏。如果同时 "),t("code",[_._v("setState")]),_._v(" 多个不同的值，则会在更新时对其进⾏合并批量更新。")]),_._v(" "),t("h2",{attrs:{id:"_4-react中如何实现组件间的通信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-react中如何实现组件间的通信"}},[_._v("#")]),_._v(" 4. React中如何实现组件间的通信？")]),_._v(" "),t("p",[_._v("组件间通信⽅式一共有如下几种：")]),_._v(" "),t("ol",[t("li",[_._v("⽗组件向⼦组件通讯")])]),_._v(" "),t("p",[_._v("⽗组件可以通过向⼦组件传 "),t("code",[_._v("props")]),_._v(" 的⽅式来实现父到子的通讯。")]),_._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[_._v("⼦组件向⽗组件通讯")])]),_._v(" "),t("p",[_._v("可以采用 "),t("code",[_._v("props + 回调")]),_._v(" 的⽅式。")]),_._v(" "),t("p",[_._v("当⽗组件向⼦组件传递 "),t("code",[_._v("props")]),_._v(" 进⾏通讯时，可在该 "),t("code",[_._v("props")]),_._v(" 中传递一个回调函数，当⼦组件调⽤该函数时，可将⼦组件中想要传递给父组件的信息作为参数传递给该函数。由于 "),t("code",[_._v("props")]),_._v(" 中的函数作⽤域为⽗组件⾃身，因此可以通过该函数内的 "),t("code",[_._v("setState")]),_._v(" 更新到⽗组件上。")]),_._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[_._v("兄弟组件通信")])]),_._v(" "),t("p",[_._v("可以通过兄弟节点的共同⽗节点，再结合以上2种⽅式，由⽗节点转发信息，实现兄弟间通信。")]),_._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[_._v("跨层级通信")])]),_._v(" "),t("p",[_._v("可以采用 React 中的 "),t("code",[_._v("Context")]),_._v(" 来实现跨越多层的全局数据通信。")]),_._v(" "),t("p",[t("code",[_._v("Context")]),_._v(" 设计的⽬的是为在⼀个组件树中共享 “全局” 数据，如：当前已登录的⽤户、界面主题、界面语⾔等信息。")]),_._v(" "),t("ol",{attrs:{start:"5"}},[t("li",[_._v("发布订阅模式")])]),_._v(" "),t("p",[_._v("发布者发布事件，订阅者监听到事件后做出反应。")]),_._v(" "),t("p",[_._v("我们可以通过引⼊ "),t("code",[_._v("event")]),_._v(" 模块进⾏此种方式的通信。")]),_._v(" "),t("ol",{attrs:{start:"6"}},[t("li",[_._v("全局状态管理⼯具")])]),_._v(" "),t("p",[_._v("可以借助 "),t("code",[_._v("Redux")]),_._v(" 或 "),t("code",[_._v("Mobx")]),_._v(" 等全局状态管理⼯具进⾏通信，它们会维护⼀个全局状态中⼼（Store），并可以根据不同的事件产⽣新的状态。")]),_._v(" "),t("img",{staticStyle:{zoom:"30%"},attrs:{src:e(5855),alt:"image-20210223093430679"}}),_._v(" "),t("h2",{attrs:{id:"_5-react存在哪些性能优化手段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-react存在哪些性能优化手段"}},[_._v("#")]),_._v(" 5. React存在哪些性能优化手段？")]),_._v(" "),t("p",[_._v("前端项目的性能手段，其实都是相通的。我们可以参考文章："),t("a",{attrs:{href:"https://blog.csdn.net/weixin_33976072/article/details/93168109",target:"_blank",rel:"noopener noreferrer"}},[_._v("前端性能优化"),t("OutboundLink")],1)]),_._v(" "),t("h2",{attrs:{id:"_6-react中如何进行组件和逻辑的复用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-react中如何进行组件和逻辑的复用"}},[_._v("#")]),_._v(" 6. React中如何进行组件和逻辑的复用？")]),_._v(" "),t("p",[_._v("React 中的组件抽象的技术有以下几种:")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("混合（mixin，官方已废弃）")])]),_._v(" "),t("li",[t("p",[_._v("⾼阶组件（hoc）：属性代理、反向继承")])]),_._v(" "),t("li",[t("p",[_._v("渲染属性（render props）")])]),_._v(" "),t("li",[t("p",[_._v("React Hooks（配合函数式组件使用，函数拆分的复用理念）")])])]),_._v(" "),t("h2",{attrs:{id:"_7-mixin、hoc、render-props、react-hooks的优缺点分别是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-mixin、hoc、render-props、react-hooks的优缺点分别是什么"}},[_._v("#")]),_._v(" 7. Mixin、HoC、Render props、React Hooks的优缺点分别是什么？")]),_._v(" "),t("p",[t("strong",[_._v("Mixin")])]),_._v(" "),t("ul",[t("li",[t("p",[_._v("组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖于组件的特定⽅法，但在定义组件时并不知道这种依赖关系）")])]),_._v(" "),t("li",[t("p",[_._v("多个 Mixin 之间可能产⽣冲突，⽐如：多个 Mixin 中定义了相同的 state 字段，在一个组件中同时引入这些 Mixin 后会产生字段冲突")])]),_._v(" "),t("li",[t("p",[_._v("Mixin 倾向于增加更多状态，这降低了应⽤的可预测性，状态越多越难管理和溯源，复杂度剧增")])]),_._v(" "),t("li",[t("p",[_._v("隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("难以快速理解组件的⾏为，需要全盘了解所有依赖 Mixin 的扩展⾏为及其之间的相互影响")])]),_._v(" "),t("li",[t("p",[_._v("33333组件⾃身的⽅法和 state 字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它")])]),_._v(" "),t("li",[t("p",[_._v("Mixin 也难以维护，因为 Mixin 逻辑最后会被摊平合并到⼀起，很难搞清楚⼀个 Mixin 的输⼊输出")])])])])]),_._v(" "),t("p",[t("strong",[_._v("HoC")])]),_._v(" "),t("p",[_._v("优点：")]),_._v(" "),t("p",[_._v("相⽐ Mixin，HoC 通过外层组件传递 props 来影响内层组件的状态，⽽不是直接改变其 state，这就不存在冲突和互相⼲扰，降低了耦合度。不同于 Mixin 的打平 + 合并，HoC 天然具有层级结构（组件树结构），这⼜降低了复杂度。")]),_._v(" "),t("p",[_._v("缺点：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("扩展性限制：HoC ⽆法从外部访问⼦组件的 state，因此⽆法通过 "),t("code",[_._v("shouldComponentUpdate")]),_._v(" 滤掉不必要的更新；React 在⽀持ES6 Class 之后提供了 "),t("code",[_._v("React.PureComponent")]),_._v(" 解决了这个问题")])]),_._v(" "),t("li",[t("p",[_._v("Ref 传递问题：Ref 被隔断。后来出现了 "),t("code",[_._v("React.forwardRef")]),_._v(" 来解决了这个问题")])]),_._v(" "),t("li",[t("p",[_._v("包装地狱（Wrapper Hell）：和回调函数类似，HoC 如果出现多层包裹组件的情况，就会和回调函数一样层层嵌套；而这种多层抽象同样也增加了复杂度和理解成本")])]),_._v(" "),t("li",[t("p",[_._v("命名冲突：如果⾼阶组件多次嵌套而没有使⽤命名空间，就可能会产⽣冲突，覆盖⽼的属性")])]),_._v(" "),t("li",[t("p",[_._v("不可⻅性：HoC 相当于在原有组件外层再包装⼀个组件，你有可能压根都不知道外层的包装是什么，对于你来说完全是⿊盒")])])]),_._v(" "),t("p",[t("strong",[_._v("Render Props")])]),_._v(" "),t("p",[_._v("优点：")]),_._v(" "),t("p",[_._v("上述所说的 HoC 缺点，使用 Render Props 都可得到解决。")]),_._v(" "),t("p",[_._v("缺点：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("使⽤繁琐：HoC 使⽤只需要借助装饰器语法，通常⼀⾏代码就可以进⾏复⽤，而 Render Props ⽆法做到如此简单")])]),_._v(" "),t("li",[t("p",[_._v("嵌套过深：Render Props 虽然摆脱了组件多层嵌套问题，但其又会走回到了回调函数的嵌套问题")])])]),_._v(" "),t("p",[t("strong",[_._v("React Hooks")])]),_._v(" "),t("p",[_._v("优点：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("简洁：React Hooks 解决了 HoC 和 Render Props 的嵌套问题，代码更加简洁")])]),_._v(" "),t("li",[t("p",[_._v("解耦：React Hooks 可以更⽅便地把 UI 和状态分离，做到更彻底的解耦")])]),_._v(" "),t("li",[t("p",[_._v("组合：Hooks 中可以通过引⽤另外的 Hooks 以此形成新的 Hooks，变化丰富")])]),_._v(" "),t("li",[t("p",[_._v("函数友好：React Hooks 为函数组件⽽⽣，从⽽解决了类组件的⼏⼤问题:")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("this 指向容易错误")])]),_._v(" "),t("li",[t("p",[_._v("分割在不同声明周期中的逻辑会使得代码难以理解和维护")])]),_._v(" "),t("li",[t("p",[_._v("代码复⽤成本⾼（⾼阶组件容易使代码量剧增）")])])])])]),_._v(" "),t("p",[_._v("缺点：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("有额外的学习成本（需要学习和区分类组件、函数组件）")])]),_._v(" "),t("li",[t("p",[_._v("写法上有限制（不能出现在条件、循环中），并且这种写法限制会增加代码重构时的成本")])]),_._v(" "),t("li",[t("p",[_._v("破坏了 "),t("code",[_._v("PureComponent")]),_._v("、"),t("code",[_._v("React.memo")]),_._v(" 浅⽐较的性能优化效果（为了获取最新的 props 和 state，每次 "),t("code",[_._v("render()")]),_._v(" 都要重新")])])]),_._v(" "),t("p",[_._v("创建事件处理函数）")]),_._v(" "),t("ul",[t("li",[_._v("在闭包场景中可能会引⽤到旧的 state、props 值")]),_._v(" "),t("li",[_._v("内部实现上不直观（依赖⼀份可变的全局状态，不再那么“纯”）")]),_._v(" "),t("li",[t("code",[_._v("React.memo")]),_._v(" 并不能完全替代 "),t("code",[_._v("shouldComponentUpdate")]),_._v("（因为获取不到 state 的变化，只针对 props 的变化）")])]),_._v(" "),t("h2",{attrs:{id:"_8-redux的工作流程是怎么样的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-redux的工作流程是怎么样的"}},[_._v("#")]),_._v(" 8. Redux的工作流程是怎么样的？")]),_._v(" "),t("p",[t("strong",[_._v("核心概念")])]),_._v(" "),t("ul",[t("li",[t("p",[t("code",[_._v("Store")]),_._v("：一个保存数据的容器，整个应⽤只有⼀个 Store")])]),_._v(" "),t("li",[t("p",[t("code",[_._v("State")]),_._v("：Store 对象内包含所有数据，如想得到某一时间点的数据，就要对 Store ⽣成快照，这种时间点的数据集合，就叫 State")])]),_._v(" "),t("li",[t("p",[t("code",[_._v("Action")]),_._v("：State 的变化会导致 View 的变化，但⽤户是接触不到 State 的，只能接触到 View，所以 State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发⽣变化了")])]),_._v(" "),t("li",[t("p",[t("code",[_._v("Action Creator")]),_._v("：View 要发送多少种消息，就需要有多少种 Action，如果都⼿写会比较麻烦，因此我们通常会定义一个用于生成 Action 的函数，该函数就被称为 Action Creator")])]),_._v(" "),t("li",[t("p",[t("code",[_._v("Reducer")]),_._v("：在 Store 收到 Action 以后，必须给出⼀个新的 State，这样 View 才会发⽣变化。这种 State 的计算过程就叫做Reducer。Reducer 是⼀个函数，它接收 Action 和当前 State 作为参数，返回值是⼀个新的 State")])]),_._v(" "),t("li",[t("p",[t("code",[_._v("dispatch")]),_._v("：是 View 发送 Action 的唯⼀⽅法")])])]),_._v(" "),t("p",[t("strong",[_._v("⼯作流程")])]),_._v(" "),t("img",{staticStyle:{zoom:"90%"},attrs:{src:e(5856),alt:"image-20210223103127034"}}),_._v(" "),t("p",[_._v("⼀次⽤户交互的流程如下：")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("⾸先，View（通过⽤户）发出 Action，发出⽅式就是使用 "),t("code",[_._v("dispatch")]),_._v(" ⽅法")])]),_._v(" "),t("li",[t("p",[_._v("然后，Store 调⽤ Reducer 并且传⼊两个参数（当前的 State 和收到的 Action），Reducer 处理后返回新的 State")])]),_._v(" "),t("li",[t("p",[_._v("State ⼀旦有变化，则 Store 会调⽤监听函数来通知 View 进行更新")])])]),_._v(" "),t("p",[_._v("注意，在整个流程中，数据都是单向流动的，我们称之为单向数据流，这种⽅式可以保证流程的清晰性。")]),_._v(" "),t("h2",{attrs:{id:"_9-react-redux这个库是如何工作的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-react-redux这个库是如何工作的"}},[_._v("#")]),_._v(" 9. react-redux这个库是如何工作的？")]),_._v(" "),t("p",[t("strong",[_._v("核心概念")])]),_._v(" "),t("p",[t("strong",[t("code",[_._v("Provider")])])]),_._v(" "),t("p",[_._v("Provider 的作⽤是从最外部封装了整个应⽤，并向 "),t("code",[_._v("connect")]),_._v(" 模块传递 "),t("code",[_._v("store")]),_._v(" 。")]),_._v(" "),t("p",[t("strong",[t("code",[_._v("connect")])])]),_._v(" "),t("p",[_._v("负责将 React 和 Redux 关联起来，它的作用主要如下：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("获取 "),t("code",[_._v("state")]),_._v("："),t("code",[_._v("connect")]),_._v(" 先通过 "),t("code",[_._v("context")]),_._v(" 来获取存放在 "),t("code",[_._v("Provider")]),_._v(" 中的 "),t("code",[_._v("store")]),_._v("，然后通过 "),t("code",[_._v("store.getState()")]),_._v(" 来获取整个 "),t("code",[_._v("store tree")]),_._v(" 上所存放的 "),t("code",[_._v("state")])])]),_._v(" "),t("li",[t("p",[_._v("包装原组件："),t("code",[_._v("connect")]),_._v(" 将 "),t("code",[_._v("state")]),_._v(" 和 "),t("code",[_._v("action")]),_._v(" 通过 "),t("code",[_._v("props")]),_._v(" 传⼊到原组件的内部，并调用 "),t("code",[_._v("wrapWithConnect")]),_._v(" 函数来包装和返回⼀个 "),t("code",[_._v("Connect")]),_._v(" 对象，"),t("code",[_._v("Connect")]),_._v(" 对象重新 "),t("code",[_._v("render")]),_._v(" 外部传⼊的原组件，并把 "),t("code",[_._v("connect")]),_._v(" 中传⼊的 "),t("code",[_._v("mapStateToProps")]),_._v(" 和 "),t("code",[_._v("mapDispatchToProps")]),_._v(" 与组件原有的 "),t("code",[_._v("props")]),_._v(" 合并后，通过属性的⽅式传给包装组件")])]),_._v(" "),t("li",[t("p",[_._v("监听 "),t("code",[_._v("store tree")]),_._v(" 变化："),t("code",[_._v("connect")]),_._v(" 缓存了 "),t("code",[_._v("store tree")]),_._v(" 中 "),t("code",[_._v("state")]),_._v(" 的状态，通过对比当前 "),t("code",[_._v("state")]),_._v(" 和变更前 "),t("code",[_._v("state")]),_._v("，确定是否需要调⽤ "),t("code",[_._v("this.setState()")]),_._v(" ⽅法，以此触发 "),t("code",[_._v("Connect")]),_._v(" 及其⼦组件的重新渲染")])])]),_._v(" "),t("p",[t("strong",[_._v("流程图")])]),_._v(" "),t("p",[t("img",{attrs:{src:e(5857),alt:"image-20210223104924017"}})]),_._v(" "),t("h2",{attrs:{id:"_10-redux和mobx的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-redux和mobx的区别"}},[_._v("#")]),_._v(" 10. Redux和Mobx的区别？")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("比较点")]),_._v(" "),t("th",[_._v("Redux")]),_._v(" "),t("th",[_._v("Mobx")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("存储方式")]),_._v(" "),t("td",[_._v("保存在单⼀的 store 中")]),_._v(" "),t("td",[_._v("保存在分散的多个 store 中")])]),_._v(" "),t("tr",[t("td",[_._v("数据结构")]),_._v(" "),t("td",[_._v("使⽤ plain object 保存数据，需要⼿动处理变化后的操作")]),_._v(" "),t("td",[_._v("使⽤ observable 保存数据，数据变化后⾃动处理响应的操作（类似 Vuex）")])]),_._v(" "),t("tr",[t("td",[_._v("数据可变性")]),_._v(" "),t("td",[_._v("不可变状态，只读不能直接修改，应使⽤纯函数返回⼀个新状态")]),_._v(" "),t("td",[_._v("状态是可变的，可直接进⾏修改")])]),_._v(" "),t("tr",[t("td",[_._v("难易度")]),_._v(" "),t("td",[_._v("比较复杂"),t("br"),_._v("涉及函数式编程思想，掌握起来不那么容易，同时需借助⼀些中间件处理异步和副作⽤")]),_._v(" "),t("td",[_._v("比较简单"),t("br"),_._v("使用面向对象的编程思维")])]),_._v(" "),t("tr",[t("td",[_._v("调试")]),_._v(" "),t("td",[_._v("容易"),t("br"),_._v("使用纯函数，并提供了时间回溯⼯具，因此调试直观方便")]),_._v(" "),t("td",[_._v("⽐较困难"),t("br"),_._v("有更多的对象抽象和封装，调试会⽐较困难")])])])]),_._v(" "),t("p",[t("strong",[_._v("使⽤场景")])]),_._v(" "),t("p",[t("code",[_._v("Mobx")])]),_._v(" "),t("ul",[t("li",[t("p",[_._v("更适合数据不复杂的应⽤。因为 mobx 难以调试，很多状态⽆法回溯，⾯对复杂度⾼的应⽤时往往⼒不从⼼")])]),_._v(" "),t("li",[t("p",[_._v("适合短平快的项⽬。因为 mobx上⼿简单，样板代码少，很⼤程度上提⾼了开发效率")])])]),_._v(" "),t("p",[t("code",[_._v("Redux")])]),_._v(" "),t("ul",[t("li",[_._v("适合有回溯需求的应⽤。⽐如，画板、表格等应⽤，一般有撤销、重做等操作，由于 Redux 具有不可变的特性，天然⽀持这些操作")])]),_._v(" "),t("p",[_._v("我们也可以在一个项目中同时使用 "),t("code",[_._v("Mobx")]),_._v(" 和 "),t("code",[_._v("Redux")]),_._v(" ，让两者发挥各自的长处，比如：")]),_._v(" "),t("ul",[t("li",[_._v("使用 "),t("code",[_._v("Redux")]),_._v(" 作为全局状态管理")]),_._v(" "),t("li",[_._v("使⽤ "),t("code",[_._v("Mobx")]),_._v("作为组件的局部状态管理器")])]),_._v(" "),t("h2",{attrs:{id:"_11-在redux中如何进行异步操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-在redux中如何进行异步操作"}},[_._v("#")]),_._v(" 11. 在Redux中如何进行异步操作？")]),_._v(" "),t("p",[_._v("一般项目中，我们可以直接在 "),t("code",[_._v("componentDidMount")]),_._v(" 中进⾏异步操作，比如发送网络请求，⽆须借助 Redux。但如果我们的项目上了一定的规模，这种方法再管理异步流的时候就比较困难。这个时候，我们会借助 Redux 的异步中间件来进⾏异步处理。")]),_._v(" "),t("p",[_._v("Redux 其实有多种异步中间件，但当下主流的只有两种："),t("code",[_._v("redux-thunk")]),_._v(" 和 "),t("code",[_._v("redux-saga")]),_._v("。")]),_._v(" "),t("p",[t("strong",[_._v("redux-thunk")])]),_._v(" "),t("p",[_._v("优点：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("体积⼩：redux-thunk 的实现⽅式很简单，只有不到20⾏代码")])]),_._v(" "),t("li",[t("p",[_._v("使⽤简单：redux-thunk 没有引⼊像 redux-saga 或者 redux-observable 额外的编程范式，上⼿非常简单")])])]),_._v(" "),t("p",[_._v("缺点：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("样板代码过多：与 redux 本身⼀样，通常发送⼀个请求就需要编写⼤量代码，⽽且很多都是重复性的")])]),_._v(" "),t("li",[t("p",[_._v("耦合严重：异步操作与 redux 的 action 偶合在⼀起，不⽅便管理")])]),_._v(" "),t("li",[t("p",[_._v("功能薄弱：实际开发中常⽤的⼀些功能都需要⾃⼰封装")])])]),_._v(" "),t("p",[t("strong",[_._v("redux-saga")])]),_._v(" "),t("p",[_._v("优点：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("异步解耦：异步操作被被转移到了单独的 saga.js 中，不再是掺杂在 action.js 或 component.js 中")])]),_._v(" "),t("li",[t("p",[_._v("action 摆脱了 thunk function：dispatch 的参数依然是⼀个纯粹的 action (FSA)，⽽不是充满了 “⿊魔法” 的 thunk function")])]),_._v(" "),t("li",[t("p",[_._v("异常处理：受益于 Generator Function 的 saga 实现，代码异常/请求失败都可直接通过 try/catch 捕获处理")])]),_._v(" "),t("li",[t("p",[_._v("功能强⼤：redux-saga 提供了⼤量的 Saga 辅助函数和 Effect 创建器，开发者⽆须自行封装、或只要简单封装即可使⽤")])]),_._v(" "),t("li",[t("p",[_._v("灵活：redux-saga 可将多个 Saga 进行串⾏或并⾏组合，形成⼀个⾮常实⽤的异步流程")])]),_._v(" "),t("li",[t("p",[_._v("易测试：提供了各种测试⽅案，包括 mock task、分⽀覆盖等")])])]),_._v(" "),t("p",[_._v("缺点：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("额外的学习成本：redux-saga 不仅使⽤了难以理解的 Generator Function，⽽且存在数⼗个 API，学习成本远超 redux-thunk；最重要的是，这些额外的学习成本只能用于使用这个库的（而对于 redux-observable 来说，它虽也有学习成本，但它基于 rxjs ，这套编程思想和技术体系可以沿用到其他地方去）")])]),_._v(" "),t("li",[t("p",[_._v("体积庞⼤：代码近 2000 ⾏（压缩后大约 25KB）")])]),_._v(" "),t("li",[t("p",[_._v("功能过剩：其中提供的并发控制等功能，实际开发中很难会⽤到，但我们依然要引⼊这些代码")])]),_._v(" "),t("li",[t("p",[_._v("对 TS ⽀持不友好：yield ⽆法返回 TS 类型")])])]),_._v(" "),t("p",[t("strong",[_._v("redux-observable")])]),_._v(" "),t("p",[_._v("优点：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("功能最强：由于基于 rxjs 这个强⼤的响应式编程库，借助 rxjs 的操作符⼏乎可以做任何你能想到的异步处理")])]),_._v(" "),t("li",[t("p",[_._v("知识沿用：如果你已学习过 rxjs，那么 redux-observable 的学习成本并不⾼；⽽且，随着 rxjs 的升级，redux-observable 也会变得更强⼤")])])]),_._v(" "),t("p",[_._v("缺点：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("学习成本奇⾼：对于还不会 rxjs 的开发者来说，需要额外的学习两个都较为复杂的库")])]),_._v(" "),t("li",[t("p",[_._v("社区⼀般：redux-observable 下载量只有 redux-saga 的 1/5，社区不够活跃，而 redux-saga 仍处于领导地位")])])])])}),[],!1,null,null,null);v.default=o.exports}}]);