(window.webpackJsonp=window.webpackJsonp||[]).push([[277],{6209:function(v,_,r){"use strict";r.r(_);var t=r(15),s=Object(t.a)({},(function(){var v=this,_=v.$createElement,r=v._self._c||_;return r("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[r("h2",{attrs:{id:"一-跨标签页通讯"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一-跨标签页通讯"}},[v._v("#")]),v._v(" 一，跨标签页通讯")]),v._v(" "),r("p",[r("strong",[v._v("本质上通过共享中间介质")]),v._v(" "),r("br")]),v._v(" "),r("ol",[r("li",[v._v("通过父页面window.open()和子页面postMessage异步下，通过window.open('about:blank')和tab.location.href = ‘*’"),r("br")]),v._v(" "),r("li",[v._v("设置同域下共享的localStroage与监听window.onstorage"),r("br")]),v._v(" "),r("li",[v._v("设置共享cookie与不断轮训脏检查(setInterval)"),r("br")]),v._v(" "),r("li",[v._v("借用服务端或者中间层实现"),r("br")])]),v._v(" "),r("h2",{attrs:{id:"二-重绘和回流"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二-重绘和回流"}},[v._v("#")]),v._v(" 二，重绘和回流")]),v._v(" "),r("p",[r("strong",[v._v("当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流。")]),v._v(" "),r("br")]),v._v(" "),r("p",[r("strong",[v._v("重绘:")]),v._v(" "),r("br")]),v._v(" "),r("ol",[r("li",[v._v("当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要U层面的重新像素绘制，因此损耗较少 "),r("br")])]),v._v(" "),r("p",[r("strong",[v._v("回流:")]),v._v(" "),r("br")]),v._v(" "),r("ol",[r("li",[v._v("当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。 "),r("br")])]),v._v(" "),r("p",[r("strong",[v._v("触发回流条件:")]),v._v(" "),r("br")]),v._v(" "),r("ol",[r("li",[v._v("页面初次渲染 "),r("br")]),v._v(" "),r("li",[v._v("浏览器窗口大小改变 "),r("br")]),v._v(" "),r("li",[v._v("元素尺寸、位置、内容发生改变 "),r("br")]),v._v(" "),r("li",[v._v("元素字体大小变化 "),r("br")]),v._v(" "),r("li",[v._v("添加或者删除的dom元素 "),r("br")]),v._v(" "),r("li",[v._v("激活的css伪类 "),r("br")]),v._v(" "),r("li",[v._v("查询某些属性或调用某些方法 "),r("br"),v._v("\nclientWidth、clientHeight、clientTop.clientLeft "),r("br"),v._v("\noffsetWidth、offsetHeight、offsetTop、offsetLeft "),r("br"),v._v("\nscrollWidth、scrollHeight、scrollTop、scrollLeft "),r("br"),v._v("\ngetComputedStyle()  "),r("br"),v._v("\ngetBoundingClientRect()  "),r("br"),v._v("\nscrollTo()  "),r("br")])]),v._v(" "),r("p",[r("strong",[v._v("回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高")])]),v._v(" "),r("h2",{attrs:{id:"三-避免回流和重绘的最佳实践"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三-避免回流和重绘的最佳实践"}},[v._v("#")]),v._v(" 三，避免回流和重绘的最佳实践")]),v._v(" "),r("p",[r("strong",[v._v("CSS：")])]),v._v(" "),r("ol",[r("li",[v._v("避免使用table布局"),r("br")]),v._v(" "),r("li",[v._v("将动画效果应用到position属性为absolute或fixed的元素上"),r("br")])]),v._v(" "),r("p",[r("strong",[v._v("JS：")])]),v._v(" "),r("ol",[r("li",[v._v("避免频繁操作样式，可汇总后统一修改"),r("br")]),v._v(" "),r("li",[v._v("尽量使用class进行样式修改"),r("br")]),v._v(" "),r("li",[v._v("减少dom的删减次数，可使用字符串或者docuemntFragment一次性插入"),r("br")]),v._v(" "),r("li",[v._v("极限优化时，修改样式可将其display: none后修改"),r("br")]),v._v(" "),r("li",[v._v("避免多次触发上面提到的那些会触发回流的方法，可以的话尽量用变量存住"),r("br")])]),v._v(" "),r("h2",{attrs:{id:"四-http1-0-1-1-2-0的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#四-http1-0-1-1-2-0的区别"}},[v._v("#")]),v._v(" 四，HTTP1.0 1.1 2.0的区别")]),v._v(" "),r("h2",{attrs:{id:"五-websocket"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#五-websocket"}},[v._v("#")]),v._v(" 五，webSocket")]),v._v(" "),r("h2",{attrs:{id:"六-https的工作原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#六-https的工作原理"}},[v._v("#")]),v._v(" 六，HTTPS的工作原理")]),v._v(" "),r("ol",[r("li",[v._v("客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。"),r("br")]),v._v(" "),r("li",[v._v("Web服务器收到客户端请求后，会将网站的证书信息(证书中包含公钥）传送一份给客户端"),r("br")]),v._v(" "),r("li",[v._v("客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级"),r("br")]),v._v(" "),r("li",[v._v("客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站"),r("br")]),v._v(" "),r("li",[v._v("Web服务器利用自己的私钥解密出会话密钥"),r("br")]),v._v(" "),r("li",[v._v("Web服务器利用会话密钥加密与客户端之间的通信"),r("br")])]),v._v(" "),r("h2",{attrs:{id:"七-如何部署https"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#七-如何部署https"}},[v._v("#")]),v._v(" 七，如何部署https")]),v._v(" "),r("ol",[r("li",[v._v("申请SSL证书"),r("br")]),v._v(" "),r("li",[v._v("安装证书"),r("br")]),v._v(" "),r("li",[v._v("整改网站链接"),r("br")]),v._v(" "),r("li",[v._v("做301转向"),r("br")]),v._v(" "),r("li",[v._v("告诉百度抓取新连接替换旧链接"),r("br")])]),v._v(" "),r("h2",{attrs:{id:"八-输入url到返回内容的整个过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#八-输入url到返回内容的整个过程"}},[v._v("#")]),v._v(" 八，输入url到返回内容的整个过程")]),v._v(" "),r("ol",[r("li",[r("p",[v._v("通过DNS解析获得网址的对应IP地址"),r("br")])]),v._v(" "),r("li",[r("p",[v._v("通过TCP三次握手协商来建议一个TCP/IP连接"),r("br")])]),v._v(" "),r("li",[r("p",[v._v("浏览器通过TCP/IP连接向web服务器发送一个HTTP请求"),r("br")])]),v._v(" "),r("li",[r("p",[v._v("服务器的永久重定向响应(从http://example.com到http://www.example.com)"),r("br")])]),v._v(" "),r("li",[r("p",[v._v("浏览器跟踪重定向地址"),r("br")])]),v._v(" "),r("li",[r("p",[v._v("服务器处理请求"),r("br")])]),v._v(" "),r("li",[r("p",[v._v("服务器返回—个HTTP响应"),r("br")])]),v._v(" "),r("li",[r("p",[v._v("浏览器渲染"),r("br"),v._v("\nHTML parser- > DOM Tree"),r("br"),v._v("\n标记化算法，进行元素状态的标记"),r("br"),v._v("\ndom树构建"),r("br")]),v._v(" "),r("p",[v._v("cSS parser-> Style Tree"),r("br"),v._v("\n解析css代码，生成样式"),r("br")]),v._v(" "),r("p",[v._v("attachment-> Render Tree"),r("br"),v._v("\n结合dom树与style树，生成渲染树"),r("br")]),v._v(" "),r("p",[v._v("layout:布局"),r("br"),v._v("\nGPU painting:像素绘制页面"),r("br")])])]),v._v(" "),r("h2",{attrs:{id:"九-浏览器渲染网页的原理和过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#九-浏览器渲染网页的原理和过程"}},[v._v("#")]),v._v(" 九，浏览器渲染网页的原理和过程")]),v._v(" "),r("p",[r("strong",[v._v("原理：")])]),v._v(" "),r("ol",[r("li",[v._v("关键渲染路径"),r("br")]),v._v(" "),r("li",[v._v("关键渲染路径是指浏览器从最初接收请求来的HTML、CSS、JavaScript等资源，然后解析、构建树、渲染布局、绘制、最后呈现给用户能看到界面的整个过程"),r("br")])]),v._v(" "),r("p",[r("strong",[v._v("过程：")])]),v._v(" "),r("ol",[r("li",[v._v("浏览器将获取的HTML文档解析成DOM树"),r("br")]),v._v(" "),r("li",[v._v("处理CSS标记，构成层叠样式表模型"),r("br")]),v._v(" "),r("li",[v._v("将DOM和CSSOM合并成渲染树，代表一些列将被渲染的对象"),r("br")]),v._v(" "),r("li",[v._v("渲染树的每个元素包含的内容都是计算过的，它被称之为layout。浏览器使用一种流式处理的方法，只需要一次绘制操作就可以布局所有的元素"),r("br")]),v._v(" "),r("li",[v._v("将渲染树的各个节点绘制到屏幕上，这一步被称为painting"),r("br")])]),v._v(" "),r("h2",{attrs:{id:"十-什么是三次握手、四次挥手"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#十-什么是三次握手、四次挥手"}},[v._v("#")]),v._v(" 十，什么是三次握手、四次挥手")]),v._v(" "),r("h2",{attrs:{id:"十一-浏览器缓存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#十一-浏览器缓存"}},[v._v("#")]),v._v(" 十一，浏览器缓存")]),v._v(" "),r("h2",{attrs:{id:"十二-前端性能优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#十二-前端性能优化"}},[v._v("#")]),v._v(" 十二，前端性能优化")]),v._v(" "),r("p",[r("strong",[v._v("资源压缩合并开启Gzip 减少HTTP请求")])]),v._v(" "),r("ol",[r("li",[v._v("合并图片、css和js文件合并、css和js文件压缩"),r("br")]),v._v(" "),r("li",[v._v("图片较多的页面也可以使用lazyLoad等技术进行优化"),r("br")]),v._v(" "),r("li",[v._v("小图片，转base64"),r("br")])]),v._v(" "),r("p",[r("strong",[v._v("非核心代码异步加载")])]),v._v(" "),r("ol",[r("li",[v._v("动态脚本加载"),r("br")]),v._v(" "),r("li",[v._v("defer: 在HTML解析完之后才会执行。如果是多个，则按照加载的顺序依次执行"),r("br")]),v._v(" "),r("li",[v._v("async: 在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关"),r("br")])]),v._v(" "),r("p",[r("strong",[v._v("利用浏览器缓存")])]),v._v(" "),r("ol",[r("li",[v._v("强缓存"),r("br")]),v._v(" "),r("li",[v._v("协商缓存"),r("br")])]),v._v(" "),r("p",[r("strong",[v._v("使用CDN")])])])}),[],!1,null,null,null);_.default=s.exports}}]);