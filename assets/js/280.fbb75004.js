(window.webpackJsonp=window.webpackJsonp||[]).push([[280],{6206:function(t,r,e){"use strict";e.r(r);var v=e(15),_=Object(v.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"一-keys的作用是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一-keys的作用是什么"}},[t._v("#")]),t._v(" 一，keys的作用是什么")]),t._v(" "),e("p",[e("strong",[t._v("keys是React用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识")])]),t._v(" "),e("p",[e("strong",[t._v("开发过程中，保证某个元素的key在同级元素中具有唯一性。在React Diff算法中React中借助元素的key值来判断该元素是新创建的还是被移动而来的元素，从而减少不必要的元素重渲染")])]),t._v(" "),e("p",[e("strong",[t._v("注意:尽星不要使用元素在列表中的索引值作为key，因为列表中的元素顺序一旦发生改变，就可能导致大量的key失效，进而引起大量的修改操作，最好用item项的id作为key值。")])]),t._v(" "),e("h2",{attrs:{id:"二-setstate的理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二-setstate的理解"}},[t._v("#")]),t._v(" 二，setState的理解")]),t._v(" "),e("p",[e("strong",[t._v("用于修改状态，更新视图")])]),t._v(" "),e("p",[e("strong",[t._v("先了解事务Transaction")])]),t._v(" "),e("ol",[e("li",[t._v("是React中的一个调用结构，用于包装一个方法，结构为: initialize - perform(method) - close。通过事务，可以统一管理一个方法的开始与结束;处于事务流中，表示进程正在执行—些操作; "),e("br")])]),t._v(" "),e("p",[e("strong",[t._v("它是同步还是异步?")])]),t._v(" "),e("ol",[e("li",[t._v("setState并不是单纯的异步和同步,这与调用时的环境相关 "),e("br")]),t._v(" "),e("li",[t._v("在合成事件和生成周期钩子(除了componentDidUpdate）中,setState是异步的 "),e("br")]),t._v(" "),e("li",[t._v("原因 "),e("br")])]),t._v(" "),e("blockquote",[e("p",[t._v("因为在setState的实现中，有一个判断:当更新策略正在事务流的执行中时，isBatchingUpdates为true，该组件更新会被推入dirtyComponents队列中等待执行;否则，开始执行batchedUpdates队列更新;  "),e("br"),t._v("\n在生命周期钩子调用中，更新策略都处于更新之前，组件仍处于事务流中，而componentDidUpdate是在更新之后，此时组件已经不在事务流中了，因此则会同步执行;  "),e("br"),t._v("\n在合成事件中，React是基于事务流完成的事件委托机制实现，也是处于事务流中;  "),e("br")])]),t._v(" "),e("ol",{attrs:{start:"4"}},[e("li",[t._v("问题：  "),e("br")])]),t._v(" "),e("blockquote",[e("p",[t._v("无法在setState后马上从this.state上获取更新后的值  "),e("br")])]),t._v(" "),e("ol",{attrs:{start:"5"}},[e("li",[t._v("解决：  "),e("br")])]),t._v(" "),e("blockquote",[e("p",[t._v("如果需要马上同步去获取新值，setState其实是可以传入第二个参数的。setState(updater,callback)，在回调中即可获取最新值;  "),e("br")])]),t._v(" "),e("ol",{attrs:{start:"6"}},[e("li",[t._v("在原生事件和setTimeout中, setState是同步的，可以马上获取更新后的值  "),e("br")]),t._v(" "),e("li",[t._v("原因：  "),e("br")])]),t._v(" "),e("blockquote",[e("p",[t._v("原生事件是浏览器本身的实现，与事务流无关isBatchingUpdate为false，自然是同步;而setTimeout是放置与定时器线程中延后执行，此时事务流已结束，因此也是同步的;  "),e("br")])]),t._v(" "),e("ol",{attrs:{start:"8"}},[e("li",[t._v("批量更新会多次触发renter么?  "),e("br")])]),t._v(" "),e("blockquote",[e("p",[t._v("在合成事件和生命周期钩子中，setState更新队列时，存储是合并状态(Object.assign),所以只触发一次 "),e("br")])]),t._v(" "),e("ol",{attrs:{start:"9"}},[e("li",[t._v("注意事项："),e("br")])]),t._v(" "),e("blockquote",[e("p",[t._v("setState合并，在合成事件和生命周期钩子中多次连续调用会被优化一次"),e("br"),t._v("\n当组件已被销毁，如果再次调用setState，React会报错警告，通常有两种解决方法"),e("br")]),t._v(" "),e("blockquote",[e("p",[t._v("将数据挂载到外部，通过props传入，如放到Redux或父级中"),e("br"),t._v("\n在组件内部维护一个状态量,componentWillUnmount中标记为true，在setstate前进行判断"),e("br")])])]),t._v(" "),e("h2",{attrs:{id:"三-react的合成事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三-react的合成事件"}},[t._v("#")]),t._v(" 三，React的合成事件")]),t._v(" "),e("p",[e("strong",[t._v("React合成事件一套机制:React并不是将click事件直接绑定在dom上面，而是采用事件冒泡的形式冒泡到document上面，然后React将事件封装给正式的函数处理运行和处理")])]),t._v(" "),e("p",[e("strong",[t._v("如果DOM上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响。React为了避免这类DOM事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，实现了一个中间层——SyntheticEvent。")])]),t._v(" "),e("p",[e("strong",[t._v("当用户在为onClick添加函数时，React并没有将Click时间绑定在DOM上面。")])]),t._v(" "),e("p",[e("strong",[t._v("而是在document处监听所有支持的事件，当事件发生并冒泡至document时，React将事件内容封装交给中间层SyntheticEvent(负责所有事件合成)")])]),t._v(" "),e("p",[e("strong",[t._v("所以当事件触发的时候，对使用统一的分发函数dispatchEvent将指定函数执行。")])]),t._v(" "),e("h2",{attrs:{id:"四-子组件的数据依赖于父组件的componentwillreceiveprops"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四-子组件的数据依赖于父组件的componentwillreceiveprops"}},[t._v("#")]),t._v(" 四，子组件的数据依赖于父组件的componentWillReceiveProps")]),t._v(" "),e("p",[e("strong",[t._v("如果子组件的数据依赖于父组件，将会执行一个钩子函数componentWillReceiveProps，在生命周期的第一次render后不会被调用，但是会在之后的每次render中被调用=当父组件再次传送props")])]),t._v(" "),e("h2",{attrs:{id:"五-react性能优化是那个周期函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五-react性能优化是那个周期函数"}},[t._v("#")]),t._v(" 五，react性能优化是那个周期函数")]),t._v(" "),e("p",[e("strong",[t._v("shouldComponentUpdate这个方法用来判断是否需要调用render方法重新描绘dom。因为dom的描绘非常消耗性能，如果我们能在 shouldComponentUpdate方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。")])]),t._v(" "),e("h2",{attrs:{id:"六-为什么说虚拟dom会提高性能"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#六-为什么说虚拟dom会提高性能"}},[t._v("#")]),t._v(" 六，为什么说虚拟DOM会提高性能")]),t._v(" "),e("p",[e("strong",[t._v("它不会直接操作原生的DOM节点，因为这个很消耗性能")])]),t._v(" "),e("p",[e("strong",[t._v("当组件状态变化时它会通过某些diff算法去计算出本次数据更新真实的视图变化，然后只改变“需要改变”的DOM节点。")])]),t._v(" "),e("p",[e("strong",[t._v("虚拟dom相当于在js和真实dom 中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能。")])]),t._v(" "),e("p",[e("strong",[t._v("用过React的人可能都会体会到React并没有想象中那么高效，框架有时候会做很多无用功，这体现在很多组件会被“无缘无故”进行重渲染(re-render)。注意这里说的re-render和对原生DOM进行操作是两码事!所谓的re-render是你定义的class Component的render方法被重新执行，或者你的组件函数被重新执行。组件被重渲染是因为Vtual DOM的高效是建立在diff算法上的，而要有diff一定要将组件重渲染才能知道组件的新状态和旧状态有没有发生改变，从而才能计算出哪些DOM需要被更新。")])]),t._v(" "),e("h2",{attrs:{id:"七-react组件什么时候会重渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#七-react组件什么时候会重渲染"}},[t._v("#")]),t._v(" 七，react组件什么时候会重渲染")]),t._v(" "),e("p",[e("strong",[t._v("组件的state变化时")]),t._v(" "),e("br")]),t._v(" "),e("ol",[e("li",[t._v("props的改变 "),e("br")]),t._v(" "),e("li",[t._v("直接修改setState方法改变 "),e("br")])]),t._v(" "),e("p",[e("strong",[t._v("但是react默认行为设计默认每次都重新渲染，应该在shouldComponentUpdate函数中告诉组件是否重新渲染")]),e("br")]),t._v(" "),e("h2",{attrs:{id:"八-react-diff原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#八-react-diff原理"}},[t._v("#")]),t._v(" 八，React diff原理")]),t._v(" "),e("ol",[e("li",[t._v("把树形结构按照层级分解，只比较同级元素"),e("br")]),t._v(" "),e("li",[t._v("给列表结构的每个单元添加唯一的key属性，方便比较"),e("br")]),t._v(" "),e("li",[t._v("react只会匹配相同的class的component(class指的是组件的名字)"),e("br")]),t._v(" "),e("li",[t._v("合并操作，调用component的setState方法的时候，React将其标记为dirty,到每一个事件循环结束，React检查所有标记dirty的component重新绘制"),e("br")]),t._v(" "),e("li",[t._v("选择性子树渲染。开发人员可以重写shouldComponentUpdate提高diff的性能"),e("br")])]),t._v(" "),e("h2",{attrs:{id:"九-无状态组件和纯组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#九-无状态组件和纯组件"}},[t._v("#")]),t._v(" 九，无状态组件和纯组件")]),t._v(" "),e("p",[e("strong",[t._v("无状态组件可以通过减少继承Component而来的生命周期函数而达到性能优化的效果")])]),t._v(" "),e("ol",[e("li",[t._v("单纯的render函数，没有所谓的shouldComponentUpdate生命周期函数，所以每次state更新，都会重新绘制render函数。所以无状态组件一般都会只是展示性的组件 "),e("br")])]),t._v(" "),e("p",[e("strong",[t._v("纯组件是通过控制shouldComponentUpdate生命周期函数，减少render调用次数来减少性能损耗的")])]),t._v(" "),e("ol",[e("li",[t._v("这相对于Component来说，减少了手动判断state变化的繁琐操作，但该组件也具有一定的缺陷，因为它只能进行一层浅比较，简单来说，它只比较props和state的内存地址，如果内存地址相同，则shouldComponentUpdate生命周期就返回false。"),e("br")]),t._v(" "),e("li",[t._v("PureComponent使用场景: PureComponent的使用场景应该是局部数据发生改变的场景，比如带有输入框、switch开关等的U组件就可以使用PureComponent组件封装。 "),e("br")]),t._v(" "),e("li",[t._v("PureComponent最佳实践: PureComponent中如果有数据操作最好配合一个第三方组件——Immutable一起使用，Immutable需要使用npm安装该插件才可以使用，因为lmmutable可以保证数据的不变性。"),e("br")])]),t._v(" "),e("h2",{attrs:{id:"十-react-hook"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#十-react-hook"}},[t._v("#")]),t._v(" 十，React hook")]),t._v(" "),e("p",[e("strong",[t._v("生的背景")])]),t._v(" "),e("ol",[e("li",[t._v("组件之间复用状态逻辑很难，在hooks之前，实现组件复用，一般采用高阶组件和Render Props，他们本质是将复用逻辑提升到父组件中，很容易产生很多包装组件，带来嵌套地狱"),e("br")]),t._v(" "),e("li",[t._v("组件逻辑变得越来越复杂，尤其是生命周期函数中尝尝包含一些不相关的逻辑，完全不相关的代码却在同一个方法中组合在一起。如此很容易产生bug，并且导致逻辑不—致"),e("br")]),t._v(" "),e("li",[t._v("复杂的class组件，使用class组件，需要理解js的this的工作模式，不能忘记绑定事件处理器等操作，代码复杂且冗余。除此之外，class组件也会让—些react优化措施失效"),e("br")])]),t._v(" "),e("p",[e("strong",[t._v("hooks的优点")])]),t._v(" "),e("ol",[e("li",[t._v("用于在函数组件中引入状态管理和生命周期方法"),e("br")]),t._v(" "),e("li",[t._v("取代高阶组件和render props来实现抽象和可重用性"),e("br")])]),t._v(" "),e("p",[e("strong",[t._v("知道HOC和render props吗?他们有什么作用?有什么弊端")])]),t._v(" "),e("ol",[e("li",[t._v("Render Props 组件和高阶组件主要用来实现抽象和可重用性。"),e("br")]),t._v(" "),e("li",[t._v("弊端就是高阶组件和Render Props本质上都是将复用逻辑提升到父组件中，很容易产生很多包装组件，带来的「嵌套地域」。由于所有抽象逻辑都被其他React组件所隐藏，应用变成了一棵没有可读性的组件树。而那些可见的组件也很难在浏览器的DOM中进行跟踪。"),e("br")])]),t._v(" "),e("p",[e("strong",[t._v("什么是Render Props")])]),t._v(" "),e("ol",[e("li",[t._v("定义：render props模式是一种非常灵活复用性非常高的模式，它可以把特定行为或功能封装成一个组件，提供给其他组件使用让其他组件拥有这样的鲐力。他把组件可以动态渲染的地方暴露给外部，你不用再关注组件的内部实现，只要把数据通过函数传出去就好。"),e("br")]),t._v(" "),e("li",[t._v("使用场景：A)通用业务逻辑的抽取  B)当两个平级组件之间需要单向依赖的时候，比如两个同级组件A、B，A组件需要跟随B组件的内部状态来改变自己的内部状态，我们就说A依赖B;或者B依赖A"),e("br")])]),t._v(" "),e("p",[e("strong",[t._v("HOC")])]),t._v(" "),e("ol",[e("li",[t._v("定义：hoc是React中用于重用组件逻辑的高级技术，它是一个函数，能够接受一个组件并返回一个新的组件"),e("br")]),t._v(" "),e("li",[t._v("实现方式：")])]),t._v(" "),e("blockquote",[e("p",[t._v("属性代理。高阶组件通过包裹的React组件来操作props"),e("br"),t._v("\n反向继承。高阶组件继承于被包裹的React组件"),e("br")])]),t._v(" "),e("h2",{attrs:{id:"十一-refs和react-forwardref的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#十一-refs和react-forwardref的区别"}},[t._v("#")]),t._v(" 十一，refs和React.forwardRef的区别")]),t._v(" "),e("p",[e("strong",[t._v("Refs:")])]),t._v(" "),e("ol",[e("li",[t._v("可以访问dom元素或者组件实例"),e("br")]),t._v(" "),e("li",[t._v("建议不要过度使用"),e("br")])]),t._v(" "),e("blockquote",[e("p",[t._v("有需要直接触达和操作子孙组件实例或者操作子dom元素的情况，这时候应该使用React Ref。"),e("br"),t._v("\n如果属性下传能够解决问题，应该使用声明式的属性传递，而非命令式的ref"),e("br")])]),t._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[t._v("使用场景"),e("br")])]),t._v(" "),e("blockquote",[e("p",[t._v("用于处理立即执行的动画"),e("br"),t._v("\n用来处理非受控组件的焦点"),e("br"),t._v("\n用来与第三方库对接"),e("br")])]),t._v(" "),e("p",[e("strong",[t._v("forwardRef:")])]),t._v(" "),e("ol",[e("li",[t._v("自动透传引用(Ref),能让组件接收传过来的ref，向下传递ref"),e("br")]),t._v(" "),e("li",[t._v("应用在高阶组件中转发refs"),e("br")])]),t._v(" "),e("h2",{attrs:{id:"十二-状态state和属性props之间有何不同"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#十二-状态state和属性props之间有何不同"}},[t._v("#")]),t._v(" 十二，状态state和属性props之间有何不同")]),t._v(" "),e("p",[e("strong",[t._v("State 是一种数据结构，用于组件挂载时所需数据的默认值。State可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果")])]),t._v(" "),e("p",[e("strong",[t._v("Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据--回调函数也可以通过props传递。")])]),t._v(" "),e("h2",{attrs:{id:"十三-react生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#十三-react生命周期"}},[t._v("#")]),t._v(" 十三，React生命周期")]),t._v(" "),e("p",[e("strong",[t._v("在新版本中，React官方对生命周期有了新的变动建议;")]),e("br")]),t._v(" "),e("ol",[e("li",[t._v("使用getDerivedStateFromProps替换 componentWillMount与componentWillReceiveProps; "),e("br")]),t._v(" "),e("li",[t._v("使用getSnapshotBeforeUpdate替换componentWillUpdate; "),e("br")])]),t._v(" "),e("p",[e("strong",[t._v("最佳实践")])]),t._v(" "),e("ol",[e("li",[t._v("在constructor初始化 state; "),e("br")]),t._v(" "),e("li",[t._v("在componentDidMount中进行事件监听，并在componentWillUnmount中解绑事件 "),e("br")]),t._v(" "),e("li",[t._v("在componentDidMount中进行数据的请求，而不是在componentWillMount; "),e("br")]),t._v(" "),e("li",[t._v("需要根据props更新 state时，使用getDerivedStateFromProps(nextProps, prevState); "),e("br")]),t._v(" "),e("li",[t._v("在componentDidUpdate使用setState时，必须加条件，否则将进入死循环; "),e("br")]),t._v(" "),e("li",[t._v("getSnapshotBeforeUpdate(prevProps, prevState)可以在更新之前获取最新的渲染数据，它的调用是在render之后,update之前; "),e("br")]),t._v(" "),e("li",[t._v("shouldComponentUupdate:默认每次调用setState，一定会最终走到dff阶段，但可以通过shouldComponentupdate的生命钩子返回false来直接阻止后面的逻辑执行，通常是用于做条件渲染，优化渲染的性能。 "),e("br")])]),t._v(" "),e("h2",{attrs:{id:"十四-hoc高阶组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#十四-hoc高阶组件"}},[t._v("#")]),t._v(" 十四，HOC高阶组件")]),t._v(" "),e("p",[e("strong",[t._v("高阶组件不是组件，是增强函数，可以输入一个元组件，返回出一个新的增强组件;我给你一个赛亚人，你给我一个超级赛亚人")])]),t._v(" "),e("p",[e("strong",[t._v("主要作用")])]),t._v(" "),e("ol",[e("li",[t._v("代码复用，操作状态和参数;"),e("br")])]),t._v(" "),e("p",[e("strong",[t._v("用法:基于被包裹组件的功能增强")])]),t._v(" "),e("ol",[e("li",[t._v("默认参数:可以为组件包括—层默认参数"),e("br")]),t._v(" "),e("li",[t._v("提取状态:可以通过props将被包裹组件中的state 依赖外层，例如用于转换受控组件:"),e("br")]),t._v(" "),e("li",[t._v("包裹组件:可以为被包裹元素进行—层包装"),e("br")]),t._v(" "),e("li",[t._v("反向继承:返回出—个组件，继承自被包裹组件。"),e("br")])]),t._v(" "),e("p",[e("strong",[t._v("应用场景")])]),t._v(" "),e("ol",[e("li",[t._v("权限控制:通过抽象逻辑，统一对页面进行权限判断，按不同的条件进行页面渲染"),e("br")]),t._v(" "),e("li",[t._v("性能监控，包括组件的生命周期，进行统─埋点"),e("br")]),t._v(" "),e("li",[t._v("代码复用，可以将重复的逻辑进行抽象"),e("br")])]),t._v(" "),e("p",[e("strong",[t._v("使用注意")])]),t._v(" "),e("ol",[e("li",[t._v("纯函数:增强函数应为纯函数，避免侵入修改原组件;"),e("br")]),t._v(" "),e("li",[t._v("避免用法污染:理想状态下，应透传原组件的无关参数与事件，尽量保证用法不变"),e("br")]),t._v(" "),e("li",[t._v("命名空间:为HOC增加特异性的组件名称，这样能便于开发调试和查找问题"),e("br")]),t._v(" "),e("li",[t._v("引用传递:如果需要传递原组件的refs 引用，可以使用React.forwardRef"),e("br")]),t._v(" "),e("li",[t._v("静态方法:元组件上的静态方法并无法被自动传出，会导致业务层无法调用;解决:函数导出 和 静态方法赋值"),e("br")]),t._v(" "),e("li",[t._v("重新渲染:由于增强函数每次调用是返回一个新组件，因此如果在Render中使用增强函数，就会导致每次都重新渲染整个HOC，而且之前的状态会丢失;"),e("br")])]),t._v(" "),e("h2",{attrs:{id:"十五-redux"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#十五-redux"}},[t._v("#")]),t._v(" 十五，Redux")]),t._v(" "),e("p",[e("strong",[t._v("概念：Redux是一个数据管理中心，可以把它理解为一个全局的 data store 实例。它通过一定的使用规则和限制，保证着数据的健壮性、可追溯和可预测性。它与React无关，可以独立运行于任何JavaScript环境中，从而也为同构应用提供了更好的数据同步通道。")])]),t._v(" "),e("p",[e("strong",[t._v("核心理念：")])]),t._v(" "),e("ol",[e("li",[t._v("单—数据源O——整个应用只有唯一的状态树，也就是所有state最终维护在一个根级Store 中;"),e("br")]),t._v(" "),e("li",[t._v("状态只读———为了保证状态的可控性，最好的方式就是监控状态的变化。那这里就两个必要条件"),e("br")])]),t._v(" "),e("blockquote",[e("p",[t._v("Redux Store中的数据无法被直接修改;"),e("br"),t._v("\n严格控制修改的执行"),e("br")])]),t._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[t._v("纯函数———规定只能通过一个纯函数(Reducer)来描述修改;"),e("br")])]),t._v(" "),e("p",[e("strong",[t._v("实现")])]),t._v(" "),e("ol",[e("li",[t._v("Store:全局Store实例，每个Redux应用下只有一个store"),e("br")])]),t._v(" "),e("blockquote",[e("p",[t._v("getStat获取state"),e("br"),t._v("\ndispatch触发action，更新state"),e("br"),t._v("\nsubscribe订阅数据变更，注册监听"),e("br")])]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("Action:它作为一个行为载体，用于映射相应的Reducer，并且它可以成为数据的载体，将数据从应用传递至store中，是store唯一的数据源;"),e("br")]),t._v(" "),e("li",[t._v("Reducer:用于描述如何修改数据的纯函数，Action属于行为名称，而Reducer便是修改行为的实质;"),e("br")])]),t._v(" "),e("h2",{attrs:{id:"十六-react-redux"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#十六-react-redux"}},[t._v("#")]),t._v(" 十六，React-redux")]),t._v(" "),e("p",[e("strong",[t._v("结合react使用")])]),t._v(" "),e("ol",[e("li",[t._v("Provider:将store通过context传入组件中"),e("br")]),t._v(" "),e("li",[t._v("connect:一个高阶组件，可以方便在React组件中使用Redux"),e("br")])]),t._v(" "),e("blockquote",[e("p",[t._v("将store通过mapStateToProps进行筛选后使用props注入组件"),e("br"),t._v("\n根据mapDispatchToProps创建方法，当组件调用时使用dispatch触发对应的action"),e("br")])]),t._v(" "),e("p",[e("strong",[t._v("Reducer的拆分和重构：")])]),t._v(" "),e("ol",[e("li",[t._v("随着项目越大，如果将所有状态的reducer全部卸载一个函数中，将会难以维护"),e("br")]),t._v(" "),e("li",[t._v("可以将reducer进行拆分，也就是函数分解，最终再使用combineReducers()进行重构合并"),e("br")])]),t._v(" "),e("p",[e("strong",[t._v("异步action:")])]),t._v(" "),e("ol",[e("li",[t._v("由于Reducer是一个严格的纯函数，因此无法在Reducer 中进行数据的请求，需要先获取数据，再dispatch(Action)即可，下面是三种不同的异步实现:"),e("br")])]),t._v(" "),e("blockquote",[e("p",[t._v("redux-thunk"),e("br"),t._v("\nredux-saga"),e("br"),t._v("\nredux-observable"),e("br")])]),t._v(" "),e("h2",{attrs:{id:"十七-react的优化手段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#十七-react的优化手段"}},[t._v("#")]),t._v(" 十七，React的优化手段")]),t._v(" "),e("p",[e("strong",[t._v("class组件的优化")])]),t._v(" "),e("ol",[e("li",[t._v("利用shouldComponentUpdate方法减少数据变化触发的重新渲染，以及以后的DOM diff"),e("br")]),t._v(" "),e("li",[t._v("使用React.PureComponent替换React.component"),e("br")]),t._v(" "),e("li",[t._v("JavaScript对象引用问题，通过手动维护，让相同的数据尽量保证引用一致，控制性能"),e("br")])]),t._v(" "),e("p",[e("strong",[t._v("Code Splitting")])]),t._v(" "),e("ol",[e("li",[t._v("可以帮你“懒加载”代码，如果你没办法直接减少应用的体积，那么不妨尝试把应用从单个 bundle拆分成单个bundle +多份动态代码的形式"),e("br")]),t._v(" "),e("li",[t._v("webpack提供了三种代码分离方法"),e("br")])]),t._v(" "),e("blockquote",[e("p",[t._v("入口起点:使用entry配置手动地分离代码"),e("br"),t._v("\n防止重复:使用CommonsChunkPlugin去重和分离chunk"),e("br"),t._v("\n动态引入:通过模块的内联函数调用来分离代码"),e("br")])]),t._v(" "),e("p",[e("strong",[t._v("组件尽可能的进行拆分、解耦")])]),t._v(" "),e("p",[e("strong",[t._v("绑定this的时候，使用在构造函数中用bind绑定this，绑定this的方式，一般有三种")])]),t._v(" "),e("ol",[e("li",[t._v("初始化构造函数bind绑定，初始化只执行一次—————最优"),e("br")]),t._v(" "),e("li",[t._v("使用时bind绑定，每次render都会执行"),e("br")]),t._v(" "),e("li",[t._v("使用箭头函数，每一次render的时候都会生成新的箭头函数"),e("br")])]),t._v(" "),e("p",[e("strong",[t._v("不要滥用props，props尽量只传需要的数据，避免多余的更新，尽量避免使用{..props}")])]),t._v(" "),e("p",[e("strong",[t._v("useMemo的提供的优化，每个函数体当中生成的对象都会有新的引用，useMemo可以保留一致的引用")])]),t._v(" "),e("p",[e("strong",[t._v("React.memo优化：")])]),t._v(" "),e("ol",[e("li",[t._v("判断参数是否，如果没有改变，就直接复用已有的组件，不重新生成"),e("br")]),t._v(" "),e("li",[t._v("React.memo有第二个参数,用于自定义判断的规则"),e("br")])]),t._v(" "),e("p",[e("strong",[t._v("usecallback优化使用React.memo包裹组件，再使用useCallback")])]),t._v(" "),e("p",[e("strong",[t._v("避免render当中的DOM操作")])]),t._v(" "),e("p",[e("strong",[t._v("使用不可突变数据结构:")])]),t._v(" "),e("ol",[e("li",[t._v("如果数据不发生改变，直接使用原始数据，配合immutable-js这个库，ImMutableS提供了不可变的数据，既要让数据改变只能通过创建新数据的方式，而不是直接修改，这很大程度的降低了前后两个数据比较时的复杂度"),e("br")]),t._v(" "),e("li",[t._v("immutable-js库比较大，可以使用简易版的seamless-immutable来替换"),e("br")])]),t._v(" "),e("p",[e("strong",[t._v("key的有效利用，有id绑定id，使用key值时，尽量不要使用索引，因为如果对数据的添加方式不是顺序添加，会导致每一次添加数据，每一个数据值的索引号都不一样，就导致了key的变化，而当key变化时，react就会认为这与之前的数据值不相同，会多次执行渲染，会造成大量的性能浪费。如果数据不发生变化时，还是建议不要绑定了")])]),t._v(" "),e("p",[e("strong",[t._v("ReactDOMServer进行服务端渲染组件，ReactDOMServer 16版本后renderToString转化成renderToNodeStream的好处React v16之后用React.hydr")])]),t._v(" "),e("p",[e("strong",[t._v("redux的性能优化")])]),t._v(" "),e("ol",[e("li",[t._v("使用redux进行重复性能数据的传递时，可以使用reselect库在内部对数据进行缓存处理，在重复调用时便可使用缓存快速加载，加载性能，类似vuex的getters "),e("br")])]),t._v(" "),e("p",[e("strong",[t._v("性能检测工具，React16之前，我们可以使用react-addons-perf工具，而在最新的16版本，我们只需要在url后加入?react pref")])]),t._v(" "),e("h2",{attrs:{id:"十八-es6中类class的super关键字"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#十八-es6中类class的super关键字"}},[t._v("#")]),t._v(" 十八，ES6中类Class的super关键字")]),t._v(" "),e("p",[e("strong",[t._v("super当做函数使用")])]),t._v(" "),e("ol",[e("li",[t._v("super当做函数调用时，代表父类的构造函数。"),e("br")]),t._v(" "),e("li",[t._v("super作为函数调用时，内部的this指的是子类实例"),e("br")])]),t._v(" "),e("p",[e("strong",[t._v("super作为对象使用")])]),t._v(" "),e("ol",[e("li",[t._v("super作为对象时，在普通方法中，指向父类的原型对象"),e("br")]),t._v(" "),e("li",[t._v("在子类普通方法中通过super调用父类的方法时，方法内部的this指向的是当前的子类实例。"),e("br")]),t._v(" "),e("li",[t._v("在静态方法中，指向父类"),e("br")]),t._v(" "),e("li",[t._v("在子类的静态方法中通过super调用父类的方法时，方法内部的 this 指向当前的子类，而不是子类的实例"),e("br")])])])}),[],!1,null,null,null);r.default=_.exports}}]);