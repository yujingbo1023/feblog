(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{2865:function(t,s,a){t.exports=a.p+"assets/img/1675135092169.40b4e09b.png"},2866:function(t,s,a){t.exports=a.p+"assets/img/1675135174025.c771f10a.png"},2867:function(t,s,a){t.exports=a.p+"assets/img/1675135277171.49476146.png"},2868:function(t,s,a){t.exports=a.p+"assets/img/1675135289725.2b402aa8.png"},2869:function(t,s,a){t.exports=a.p+"assets/img/1675135642566.e7e0a16c.png"},2870:function(t,s,a){t.exports=a.p+"assets/img/1675135677592.b2ea977a.png"},2871:function(t,s,a){t.exports=a.p+"assets/img/1675135745445.4330acfe.png"},2872:function(t,s,a){t.exports=a.p+"assets/img/1675135831388.1028a146.png"},2873:function(t,s,a){t.exports=a.p+"assets/img/1675135909742.7c1025f5.png"},2874:function(t,s,a){t.exports=a.p+"assets/img/1675136135787.0cf9db52.png"},2875:function(t,s,a){t.exports=a.p+"assets/img/1675136432517.dca7e713.png"},2876:function(t,s,a){t.exports=a.p+"assets/img/1675136574325.495528d6.png"},2877:function(t,s,a){t.exports=a.p+"assets/img/1675136725480.5d04eb2e.png"},2878:function(t,s,a){t.exports=a.p+"assets/img/1675136967494.037b9ed7.png"},2879:function(t,s,a){t.exports=a.p+"assets/img/1675137130768.4187dd1c.png"},2880:function(t,s,a){t.exports=a.p+"assets/img/1675137155379.4254044a.png"},2881:function(t,s,a){t.exports=a.p+"assets/img/1677048889060.db5e64f1.png"},2882:function(t,s,a){t.exports=a.p+"assets/img/1677049089120.d250e087.png"},2883:function(t,s,a){t.exports=a.p+"assets/img/1675149175555.b32810fc.png"},2884:function(t,s,a){t.exports=a.p+"assets/img/1675149309248.670bda18.png"},2885:function(t,s,a){t.exports=a.p+"assets/img/1675149447581.b9ea93a0.png"},2886:function(t,s,a){t.exports=a.p+"assets/img/1675149862919.b6e64fe6.png"},2887:function(t,s,a){t.exports=a.p+"assets/img/1675150126541.aaecb775.png"},2888:function(t,s,a){t.exports=a.p+"assets/img/1675150385592.83a30797.png"},2889:function(t,s,a){t.exports=a.p+"assets/img/1675150622045.939f8792.png"},2890:function(t,s,a){t.exports=a.p+"assets/img/1675150797705.7b35dc4a.png"},2891:function(t,s,a){t.exports=a.p+"assets/img/1675150777292.4cbfdce5.png"},2892:function(t,s,a){t.exports=a.p+"assets/img/1675150898274.ef7da641.png"},2893:function(t,s,a){t.exports=a.p+"assets/img/1675150932666.85f00294.png"},2894:function(t,s,a){t.exports=a.p+"assets/img/1675150995435.9b554fcc.png"},2895:function(t,s,a){t.exports=a.p+"assets/img/1675152569211.bf837ce7.png"},2896:function(t,s,a){t.exports=a.p+"assets/img/1675152874814.b5ab1de3.png"},2897:function(t,s,a){t.exports=a.p+"assets/img/1675152972870.b0838ffd.png"},2898:function(t,s,a){t.exports=a.p+"assets/img/1675153198929.d77a44ef.png"},6016:function(t,s,a){"use strict";a.r(s);var p=a(15),e=Object(p.a)({},(function(){var t=this,s=t.$createElement,p=t._self._c||s;return p("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[p("h2",{attrs:{id:"一-状态"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#一-状态"}},[t._v("#")]),t._v(" 一，状态")]),t._v(" "),p("h3",{attrs:{id:"_1-状态在类组件中的使用"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#_1-状态在类组件中的使用"}},[t._v("#")]),t._v(" 1，状态在类组件中的使用")]),t._v(" "),p("p",[t._v("前面我们定义的数据，都是普通变量，并不是状态，现在我们开始学习state。")]),t._v(" "),p("p",[t._v("安装一个react的调试插件，如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2865),alt:"1675135092169"}})]),t._v(" "),p("p",[t._v("使用之，如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2866),alt:"1675135174025"}})]),t._v(" "),p("p",[t._v("代码如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2867),alt:"1675135277171"}})]),t._v(" "),p("p",[t._v("浏览器中效果如下 ：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2868),alt:"1675135289725"}})]),t._v(" "),p("p",[t._v("尝试直接修改状态，如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2869),alt:"1675135642566"}})]),t._v(" "),p("p",[t._v("当我们点击时，报错了，如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2870),alt:"1675135677592"}})]),t._v(" "),p("p",[t._v("打印出this是und，如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2871),alt:"1675135745445"}})]),t._v(" "),p("p",[t._v("此时，就需要显示绑定this，如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2872),alt:"1675135831388"}})]),t._v(" "),p("p",[t._v("绑定this后，我们再去修改状态，如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2873),alt:"1675135909742"}})]),t._v(" "),p("p",[t._v("直接修改状态，不推荐，因为修改状态的目的还需要让模板刷新，有个专属API，叫setState，是专门来用来修改状态的，如下 ：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2874),alt:"1675136135787"}})]),t._v(" "),p("p",[t._v("我们现在的想法是让它每一次都+1，如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2875),alt:"1675136432517"}})]),t._v(" "),p("p",[t._v("虽然++在前是OK的，但是不推荐，原因是修改了两次num，一次是直接修改，一次是间接修改。最好的处理方法如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2876),alt:"1675136574325"}})]),t._v(" "),p("p",[t._v("this.setState是异步的，在React18中，永远是异步的，在React18之前，有可能是同步，有可能是异步，测试如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2877),alt:"1675136725480"}})]),t._v(" "),p("p",[t._v("上面的修改状态的写法，还不是很优雅，比较优雅的写法，如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2878),alt:"1675136967494"}})]),t._v(" "),p("p",[t._v("上在的写法，可以简写，如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2879),alt:"1675137130768"}})]),t._v(" "),p("p",[t._v("浏览器测试如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2880),alt:"1675137155379"}})]),t._v(" "),p("p",[t._v("this.setState有两种写法：")]),t._v(" "),p("ul",[p("li",[t._v("this.setState({}, callback)   在修改状态时，当新值与旧值无关时，推荐使用这种写法，callback表示当状态修改后，自动执行，当状态修完后，有一些业务逻辑放到callback中。")]),t._v(" "),p("li",[t._v("this.setState((state, props)=>({}), callback)  当新值与旧值有关时，新值由旧值计算而来，形参state永远表示旧值，建议使用这种写法。callback表示当状态修改后，自动执行，当状态修完后，有一些业务逻辑放到callback中。")])]),t._v(" "),p("p",[t._v("上面我们讲了，在类组件中如何定义状态，如何使用状态，如何修改状态。")]),t._v(" "),p("h3",{attrs:{id:"_2-修改状态的同步和异步问题"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#_2-修改状态的同步和异步问题"}},[t._v("#")]),t._v(" 2，修改状态的同步和异步问题")]),t._v(" "),p("p",[t._v("在React18之前，React16和React17，this.setState在合成事件中，是异步的。在宏任务（定时器），Promise.then中是同步的。所谓的React合成事件是指on*系列事件，生命周期函数。")]),t._v(" "),p("p",[t._v("在React18中，this.setState任务时候都是异步的。代码如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2881),alt:"1677048889060"}})]),t._v(" "),p("p",[p("img",{attrs:{src:a(2882),alt:"1677049089120"}})]),t._v(" "),p("p",[t._v("总结：")]),t._v(" "),p("ul",[p("li",[t._v("在React18之前，setState写在宏任务中，或Promise.then中，它是同步的。")]),t._v(" "),p("li",[t._v("在React18之前，setSteate写在合成事件中，是异步的。")]),t._v(" "),p("li",[t._v("在React18中，不管setState写在哪里，永远都是异步的。")])]),t._v(" "),p("p",[t._v("在V18中，setState一定是异步的，如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2883),alt:"1675149175555"}})]),t._v(" "),p("p",[t._v("如果放在定时器，如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2884),alt:"1675149309248"}})]),t._v(" "),p("p",[t._v("你要想看一下修改后状态的结果，如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2885),alt:"1675149447581"}})]),t._v(" "),p("p",[t._v("看一下如下代码，分析结果，如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2886),alt:"1675149862919"}})]),t._v(" "),p("p",[t._v("为什么是V18版本中，把this.setState设计成异步的？")]),t._v(" "),p("p",[t._v("答：为了性能优化。在V18中，无论this.setState在哪里，都是异步的，这种特性，叫”并发模式“")]),t._v(" "),p("p",[t._v("this.setState会自动合并，如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2887),alt:"1675150126541"}})]),t._v(" "),p("p",[t._v("看再如下代码：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2888),alt:"1675150385592"}})]),t._v(" "),p("h3",{attrs:{id:"_3-初识事件绑定"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#_3-初识事件绑定"}},[t._v("#")]),t._v(" 3，初识事件绑定")]),t._v(" "),p("p",[t._v("看如下事件绑定：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2889),alt:"1675150622045"}})]),t._v(" "),p("p",[t._v("上面的写法，不完美，因为在监听器中不能获取到this。this是und。解决办法有两种：")]),t._v(" "),p("ul",[p("li",[t._v("利用ES5中的bind中手动绑定this")]),t._v(" "),p("li",[t._v("利用ES6中的箭头函数自动绑定this")])]),t._v(" "),p("p",[t._v("ES5绑定代码如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2890),alt:"1675150797705"}})]),t._v(" "),p("p",[t._v("浏览器测试如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2891),alt:"1675150777292"}})]),t._v(" "),p("p",[t._v("使用ES6中的箭头函数自动绑定this，代码如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2892),alt:"1675150898274"}})]),t._v(" "),p("p",[t._v("浏览器中测试如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2893),alt:"1675150932666"}})]),t._v(" "),p("p",[t._v("想获取事件对象，如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2894),alt:"1675150995435"}})]),t._v(" "),p("h3",{attrs:{id:"_4-状态在函数组件中的使用"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#_4-状态在函数组件中的使用"}},[t._v("#")]),t._v(" 4，状态在函数组件中的使用")]),t._v(" "),p("p",[t._v("函数组件中是不能定义状态，但是配合hook可以定义状态，hook类似于vue3中的组合式API，在React16.8中就有了，React16.8有三四年，hook也有三四年，只不过，最近两年hook才火起来了。")]),t._v(" "),p("p",[t._v("直接上代码，如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2895),alt:"1675152569211"}})]),t._v(" "),p("p",[t._v("看下面的写法，有没有问题：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2896),alt:"1675152874814"}})]),t._v(" "),p("p",[t._v("setNum是同步还是异步，如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2897),alt:"1675152972870"}})]),t._v(" "),p("p",[t._v("setNum是同步还是异步，在不同的版本中是不一样的，总结如下：")]),t._v(" "),p("ul",[p("li",[t._v("在V18之前，在合成事件中是异步的，在宏任务和promise.then中是同步的。")]),t._v(" "),p("li",[t._v("在V18中，无论在哪里都是异步的。")])]),t._v(" "),p("p",[t._v("setNum中，是没有callback。setNum还有一种写法，如下：")]),t._v(" "),p("p",[p("img",{attrs:{src:a(2898),alt:"1675153198929"}})])])}),[],!1,null,null,null);s.default=e.exports}}]);