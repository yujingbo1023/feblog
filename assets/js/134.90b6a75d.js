(window.webpackJsonp=window.webpackJsonp||[]).push([[134],{5764:function(s,a,e){s.exports=e.p+"assets/img/fsadfasdfsadfd.791d4a23.png"},5765:function(s,a,e){s.exports=e.p+"assets/img/image-20210224084130350.50ebca2b.png"},6188:function(s,a,e){"use strict";e.r(a);var t=e(15),n=Object(t.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h2",{attrs:{id:"_1-说说你对-spa-单页面的理解-它的优缺点分别是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-说说你对-spa-单页面的理解-它的优缺点分别是什么"}},[s._v("#")]),s._v(" 1. 说说你对 SPA 单页面的理解，它的优缺点分别是什么？")]),s._v(" "),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。\n\n优点：\n    1）用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；\n    2）基于上面一点，SPA 相对对服务器压力小；\n    3）前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；\n\n缺点：\n    1）初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；\n    2）前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；\n    3）SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br")])]),t("h2",{attrs:{id:"_2-vue2-和-vue3的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-vue2-和-vue3的区别"}},[s._v("#")]),s._v(" 2. vue2 和 vue3的区别")]),s._v(" "),t("hr"),s._v(" "),t("img",{attrs:{src:e(5764)}}),s._v(" "),t("h2",{attrs:{id:"_3-vue-响应式原理是怎么实现的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-vue-响应式原理是怎么实现的"}},[s._v("#")]),s._v(" 3. Vue 响应式原理是怎么实现的？")]),s._v(" "),t("hr"),s._v(" "),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("响应式的核心是通过 Object.defineProperty 拦截对数据的访问和设置\n\n响应式的数据分为两类：\n    对象，循环遍历对象的所有属性，为每个属性设置 getter、setter，以达到拦截访问和设置的目的，如果属性值依旧为对象，则递归为属性值上的每个 key 设置 getter、setter\n        访问数据时（obj.key)进行依赖收集，在 dep 中存储相关的 watcher\n        设置数据时由 dep 通知相关的 watcher 去更新\n\n    数组，增强数组的那 7 个可以更改自身的原型方法，然后拦截对这些方法的操作\n        添加新数据时进行响应式处理，然后由 dep 通知 watcher 去更新\n        删除数据时，也要由 dep 通知 watcher 去更新\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br")])]),t("h2",{attrs:{id:"_4-订阅发布模式和观察者模式的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-订阅发布模式和观察者模式的区别"}},[s._v("#")]),s._v(" 4. 订阅发布模式和观察者模式的区别")]),s._v(" "),t("hr"),s._v(" "),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("订阅发布模式和观察者模式在前端使用的非常频繁。\n\n订阅发布模式分发布者和订阅，如前端事件或自定义事件就是所谓的订阅发布。订阅者订阅好，等待发布者发布，两者之间没有必然联系。\nvue中组件通信中的事件总线就是基于订阅发布的。\n\n观察者模式分观察者和被观察者，也是基于订阅发布的，观察者和被观察者之间是有关系的，在被观察者内部是保存着观察者。vue中收集依赖和派发更新就用到了观察者模式，vue中的每一个状态都对应一个Dep类，用来收集依赖，所谓的依赖就是观察者（订阅者）Watcher。一上来vue在解析渲染时, 会进行依赖收集, 会将渲染 watcher、计算属性 watcher、侦听器 watcher, 都收集到对应的dep中, 将来Object.defineProperty 监听到数据变化, 就根据依赖关系, 派发更新\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br")])]),t("h2",{attrs:{id:"_5-vue-router的实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-vue-router的实现原理"}},[s._v("#")]),s._v(" 5. vue-router的实现原理")]),s._v(" "),t("hr"),s._v(" "),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("vue-router通过hash和history inerface两种方式实现前端路由，更新视图但不重新请求页面是前端路由原理的核心之一\n\n完成上面的核心，有两种实现方式\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])]),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("hash模式\n1. 改变hash并不会引起页面重载\n2. HTTP请求不包括#,所以使用hash不会影响到其它功能\n3. 改变#会改变浏览器的访问历史\n4. 可以通过onhashChange监听hash值的变化。后来出了一个onpopState事件，也可以代替onhashchange使用\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("history模式\n1. 它是浏览器记录栈提供的接口，通过back),forward()go()我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。\n2. 从HTMLS开始，Historyinterface有进一步修炼: pushState(), replaceState()这下不仅是读取了，还可以对浏览器历史记录栈进行修改:\n3. vue-router默认会采用hash默认，如果浏览器支持history新特性，则采用history模式，否则采用hash模式，如果不在浏览器环境则使用abstract(node环境)\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("h2",{attrs:{id:"_6-hash路由和history路由区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-hash路由和history路由区别"}},[s._v("#")]),s._v(" 6. hash路由和history路由区别")]),s._v(" "),t("hr"),s._v(" "),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("1. hash虽然出现在URL中，但不会被包括在HTTP请求中。它是用来指导浏览器动作的，对服务器端完全无用，因此，改变hash不会重新加载页面每一次改变hash (window.location.hash)，都会在浏览器的访问历史中增加一个记录利用hash的以上特点，就可以来实现前端路由“更新视图但不重新请求页面”的功能了。\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("1. History接口是浏览器历史记录栈提供的接口，通过back), forward0), go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。\n2. 从HTML5开始，History interface提供了两个新的方法: pushState(), replaceState()使得我们可以对浏览器历史记录栈进行修改:\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br")])]),t("h2",{attrs:{id:"_7-vue中v-if与v-show的区别以及使用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-vue中v-if与v-show的区别以及使用场景"}},[s._v("#")]),s._v(" 7. vue中v-if与v-show的区别以及使用场景")]),s._v(" "),t("hr"),s._v(" "),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("手段：\n    v-if是通过控制dom节点的存在与否来控制元素的显隐；v-show是通过设置DOM元素的display样式，block为显示，none为隐藏；\n编译过程：\n    v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；\n编译条件：\n    v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；\n性能消耗：\n    v-if有更高的切换消耗；v-show有更高的初始渲染消耗；\n\n使用场景\n    基于以上区别，因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br")])]),t("h2",{attrs:{id:"_8-v-if和v-for为什么避免一起用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-v-if和v-for为什么避免一起用"}},[s._v("#")]),s._v(" 8. v-if和v-for为什么避免一起用")]),s._v(" "),t("hr"),s._v(" "),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('v-if和v-for一起使用，v-for的优先级要高于v-if，先循环再控制显示隐藏\n\n为了过滤一个列表中的项目（比如v-for = "user in users" v-if = "user.isActive"）。在这种情况下，请将users替换为一个计算属性（比如activeUsers），让其返回过滤后的列表。\n为了避免渲染本应该被隐藏的列表（比如v-for = "user in users" v-if = "shouldShowUsers"）。这种情况下，请将v-if移动至容器元素上（比如ul，ol）。\n')])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("h2",{attrs:{id:"_9-vuex-为什么要分模块并且加命名空间"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-vuex-为什么要分模块并且加命名空间"}},[s._v("#")]),s._v(" 9. Vuex 为什么要分模块并且加命名空间")]),s._v(" "),t("hr"),s._v(" "),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("模块:\n    由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块。\n\n命名空间：\n    默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("h2",{attrs:{id:"_10-vue3为什么要使用组合式api-vue组合式api有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-vue3为什么要使用组合式api-vue组合式api有哪些"}},[s._v("#")]),s._v(" 10. vue3为什么要使用组合式API，vue组合式API有哪些？")]),s._v(" "),t("hr"),s._v(" "),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("使用组合式API，替换原有的 Options [ˈɒpʃnz] API好处：\n    1）根据逻辑相关性组织代码，提高可读性和可维护性\n    2）更好的重用逻辑代码（避免mixins混入时命名冲突的问题）\n\n项目中常用的组合式API：\n1）setup\n2）ref\n3）reactive\n4）readonly\n5）computed\n6）watchEffect\n7）watch\n8）新生命周期函数\n\n不常用的：\n1）unref / toRef / toRefs / isRef / isProxy / isReactive / isReadonly\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br")])]),t("h2",{attrs:{id:"_11-vue组件通信传值-有哪些方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-vue组件通信传值-有哪些方式"}},[s._v("#")]),s._v(" 11. vue组件通信传值，有哪些方式？")]),s._v(" "),t("hr"),s._v(" "),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('父传子, 子传父, 非父子, Vuex\n\n1）props 和 $emit\n\n2）eventBus事件总线   适用于 父子、隔代、兄弟组件通信\n    A）这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件\n\n3）$children $parent $refs  适用 父子组件通信\n    A）ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例\n    B）$parent / $children：访问父 / 子实例\n\n4）provide inject 适用于 隔代组件通信\n    A）祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。\n\n5）$attrs $listeners  适用于 隔代组件通信\n    A）$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind="$attrs" 传入内部组件。通常配合 inheritAttrs 选项一起使用。\n    B）$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on="$listeners" 传入内部组件\n\n6）Vuex  父子、隔代、兄弟组件通信\n')])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br")])]),t("h2",{attrs:{id:"_12-谈谈对vue生命周期的理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-谈谈对vue生命周期的理解"}},[s._v("#")]),s._v(" 12. 谈谈对Vue生命周期的理解？")]),s._v(" "),t("hr"),s._v(" "),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("每个 Vue 实例(每个组件也都是一个vue实例)都有⼀个完整的⽣命周期：\n1, 开始创建 (空实例)\n2, 初始化数据\n3, 编译模版\n4, 挂载 DOM\n5, 渲染、更新数据 => 重新渲染\n6, 卸载\n\n这⼀系列过程我们称之为 Vue 的⽣命周期。\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br")])]),t("p",[t("strong",[s._v("各个生命周期的作用")])]),s._v(" "),t("table",[t("thead",[t("tr",[t("th",[s._v("生命周期")]),s._v(" "),t("th",[s._v("执行时机")])])]),s._v(" "),t("tbody",[t("tr",[t("td",[s._v("beforeCreate")]),s._v(" "),t("td",[s._v("在组件实例被创建之初、组件的属性⽣效之前被调用")])]),s._v(" "),t("tr",[t("td",[s._v("created")]),s._v(" "),t("td",[s._v("在组件实例已创建完毕。此时属性也已绑定，但真实DOM还未⽣成，$el 还不可⽤")])]),s._v(" "),t("tr",[t("td",[s._v("beforeMount")]),s._v(" "),t("td",[s._v("在组件挂载开始之前被调⽤。相关的 render 函数⾸次被调⽤")])]),s._v(" "),t("tr",[t("td",[s._v("mounted")]),s._v(" "),t("td",[s._v("在 el 被新建的 vm.$el 替换并挂载到实例上之后被调用")])]),s._v(" "),t("tr",[t("td",[s._v("beforeUpdate")]),s._v(" "),t("td",[s._v("在组件数据修改了, 视图更新之前调⽤。发⽣在虚拟 DOM 打补丁之前")])]),s._v(" "),t("tr",[t("td",[s._v("updated")]),s._v(" "),t("td",[s._v("在组件数据修改了, 视图更新之后被调用")])]),s._v(" "),t("tr",[t("td",[s._v("activited")]),s._v(" "),t("td",[s._v("在组件被激活时调⽤（使用了 "),t("code",[s._v("<keep-alive>")]),s._v(" 的情况下）")])]),s._v(" "),t("tr",[t("td",[s._v("deactivated")]),s._v(" "),t("td",[s._v("在组件被停用时调⽤（使用了 "),t("code",[s._v("<keep-alive>")]),s._v(" 的情况下）")])]),s._v(" "),t("tr",[t("td",[s._v("beforeDestory")]),s._v(" "),t("td",[s._v("在组件销毁前调⽤  (销毁: vue默认会进行释放掉实例所有的监听, 释放掉所有的组件...)")])]),s._v(" "),t("tr",[t("td",[s._v("destoryed")]),s._v(" "),t("td",[s._v("在组件销毁后调⽤  (像定时器,  webscoket连接, ... 跟vue没有太大关联的资源, 需要手动释放!)")])])])]),s._v(" "),t("p",[t("strong",[s._v("生命周期示意图")])]),s._v(" "),t("img",{attrs:{src:e(5765),alt:"image-20210224084130350"}}),s._v(" "),t("h2",{attrs:{id:"_13-vue中的key到底有什么用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-vue中的key到底有什么用"}},[s._v("#")]),s._v(" 13. Vue中的key到底有什么用？")]),s._v(" "),t("hr"),s._v(" "),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("key 是为 Vue 中的虚拟 DOM 节点（vNode）标记唯⼀性的 id。合理使用key，可以尽可能多的复用vnode。\n\nkeys是Vue用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识\n\n开发过程中，保证某个元素的key在同级元素中具有唯一性。在Diff算法中Vue中借助元素的key值来判断该元素是新创建的还是被移动而来的元素，从而减少不必要的元素重渲染\n\n注意:尽星不要使用元素在列表中的索引值作为key，因为列表中的元素顺序一旦发生改变，就可能导致大量的key失效，进而引起大量的修改操作，最好用item项的id作为key值。\n\n总结：\n    1）Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。\n    2）更准确：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。\n    3）更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快。\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br")])]),t("h2",{attrs:{id:"_14-vue-跳转路由时的传参方式-query和params的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-vue-跳转路由时的传参方式-query和params的区别"}},[s._v("#")]),s._v(" 14. Vue 跳转路由时的传参方式 (query和params的区别)")]),s._v(" "),t("hr"),s._v(" "),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("通过 query 传参, 获取: this.$route.query.username\n\n通过 params 传参, 必须通过命名路由的方式传递, 获取: this.$route.params.username\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])])])}),[],!1,null,null,null);a.default=n.exports}}]);