(window.webpackJsonp=window.webpackJsonp||[]).push([[279],{6201:function(r,v,t){"use strict";t.r(v);var e=t(15),_=Object(e.a)({},(function(){var r=this,v=r.$createElement,t=r._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("h2",{attrs:{id:"一-vue的响立式原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一-vue的响立式原理"}},[r._v("#")]),r._v(" 一，vue的响立式原理")]),r._v(" "),t("p",[t("strong",[r._v("Vue的响应式原理是核心是通过ESS5的保护对象的Object.defindeProperty 中的访问器属性中的get和set方法，data中声明的属性都被添加了访问器属性，当读取data中的数据时自动调用get方法，当修改data 中的数据时，自动调用set方法，检测到数据的变化，会通知观察者Wacher，观察者Wacher自动触发重新render当前组件(子组件不会重新渲染）,生成新的虚拟DOM树，Vue 框架会遍历并对比新虚拟DOM树和旧虚拟DOM树中每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修改到真实DOM树上。")])]),r._v(" "),t("h2",{attrs:{id:"二-订阅发布模式和观察者模式的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二-订阅发布模式和观察者模式的区别"}},[r._v("#")]),r._v(" 二，订阅发布模式和观察者模式的区别")]),r._v(" "),t("p",[t("strong",[r._v("很多人把观察者模式和订阅模式混淆一谈，其实订阅模式有一个调度中心，对订阅事件进行统一管理。而观察者模式可以随意注册事件，调用事件，虽然实现原理都雷同，设计模式上有一定的差别，实际代码运用中差别在于︰订阅模式中，可以抽离出调度中心单独成一个文件，可以对一系列的订阅事件进行统一管理。这样和观察者模式中的事件漫天飞就有千差万别了，在开发大型项目的时候，订阅/发布模式会让业务更清晰!")])]),r._v(" "),t("p",[t("strong",[r._v("观察者模式")])]),r._v(" "),t("ol",[t("li",[r._v("观察者需要直接订阅目标事件;当目标发出内容改变的事件后，直接接收事件并作出响应"),t("br")])]),r._v(" "),t("p",[t("strong",[r._v("发布订阅模式")])]),r._v(" "),t("ol",[t("li",[r._v("发布者和订阅者之间多个一个发布通道;一方面从发布者接收事件，另一个方面向订阅者发布事件;订阅者需要从事件通道订阅事件"),t("br")])]),r._v(" "),t("h2",{attrs:{id:"三-vue中对数组是如何实现响应式的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三-vue中对数组是如何实现响应式的"}},[r._v("#")]),r._v(" 三，Vue中对数组是如何实现响应式的")]),r._v(" "),t("p",[t("strong",[r._v("通过建立原型拦截器，首先数组能够修改自身的方法有push,pop,shiftunshiftsplice,sort,resverse,通过重新定义上述方法中的内容，来实现调用上述方法时触发依赖，从而通知监听该数组的订阅者执行相应的更新函数。")])]),r._v(" "),t("h2",{attrs:{id:"四-computed和watch的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四-computed和watch的区别"}},[r._v("#")]),r._v(" 四，computed和watch的区别")]),r._v(" "),t("p",[t("strong",[r._v("computed：")])]),r._v(" "),t("ol",[t("li",[r._v("支持缓存"),t("br")]),r._v(" "),t("li",[r._v("不支持异步，尽量不要做这件事"),t("br")]),r._v(" "),t("li",[r._v("一个数据受多个数据影响"),t("br")])]),r._v(" "),t("p",[t("strong",[r._v("watch：")])]),r._v(" "),t("ol",[t("li",[r._v("不支持缓存"),t("br")]),r._v(" "),t("li",[r._v("支持异步"),t("br")]),r._v(" "),t("li",[r._v("一个数据影响多个数据"),t("br")])]),r._v(" "),t("h2",{attrs:{id:"五-nexttick"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五-nexttick"}},[r._v("#")]),r._v(" 五，nextTick")]),r._v(" "),t("ol",[t("li",[r._v("异步更改DOM之后，需要对最新的DOM进行操作，此时获取不到最新的DOM"),t("br")]),r._v(" "),t("li",[r._v("而nextTick 的原理正是vue通过异步队列控制DOM更新和nextTick回调函数先后执行的方式。"),t("br")])]),r._v(" "),t("h2",{attrs:{id:"六-vue-router的实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#六-vue-router的实现原理"}},[r._v("#")]),r._v(" 六，vue-router的实现原理")]),r._v(" "),t("p",[t("strong",[r._v("vue-router通过hash和history inerface两种方式实现前端路由，更新视图但不重新请求页面是前端路由原理的核心之一")])]),r._v(" "),t("p",[t("strong",[r._v("完成上面的核心，有两种实现方式")])]),r._v(" "),t("p",[t("strong",[r._v("hash模式")])]),r._v(" "),t("ol",[t("li",[r._v("改变hash并不会引起页面重载"),t("br")]),r._v(" "),t("li",[r._v("HTTP请求不包括#,所以使用hash不会影响到其它功能"),t("br")]),r._v(" "),t("li",[r._v("改变#会改变浏览器的访问历史"),t("br")]),r._v(" "),t("li",[r._v("可以通过onhashChange监听hash值的变化。后来出了一个onpopState事件，也可以代替onhashchange使用"),t("br")])]),r._v(" "),t("p",[t("strong",[r._v("history模式")])]),r._v(" "),t("ol",[t("li",[r._v("它是浏览器记录栈提供的接口，通过back),forward()go()我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。")]),r._v(" "),t("li",[r._v("从HTMLS开始，Historyinterface有进一步修炼: pushState(), replaceState()这下不仅是读取了，还可以对浏览器历史记录栈进行修改:")]),r._v(" "),t("li",[r._v("vue-router默认会采用hash默认，如果浏览器支持history新特性，则采用history模式，否则采用hash模式，如果不在浏览器环境则使用abstract(node环境)")])]),r._v(" "),t("h2",{attrs:{id:"七-hash模式和history模式的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#七-hash模式和history模式的区别"}},[r._v("#")]),r._v(" 七，hash模式和history模式的区别")]),r._v(" "),t("p",[t("strong",[r._v("hash:")]),r._v(" "),t("br")]),r._v(" "),t("ol",[t("li",[r._v("hash虽然出现在URL中，但不会被包括在HTTP请求中。它是用来指导浏览器动作的，对服务器端完全无用，因此，改变hash不会重新加载页面每一次改变hash (window.location.hash)，都会在浏览器的访问历史中增加一个记录利用hash的以上特点，就可以来实现前端路由“更新视图但不重新请求页面”的功能了。"),t("br")])]),r._v(" "),t("p",[t("strong",[r._v("history：")]),t("br")]),r._v(" "),t("ol",[t("li",[r._v("History接口是浏览器历史记录栈提供的接口，通过back), forward0), go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。"),t("br")]),r._v(" "),t("li",[r._v("从HTML5开始，History interface提供了两个新的方法: pushState(), replaceState()使得我们可以对浏览器历史记录栈进行修改:"),t("br")])]),r._v(" "),t("h2",{attrs:{id:"八-前端如何处理并发请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#八-前端如何处理并发请求"}},[r._v("#")]),r._v(" 八，前端如何处理并发请求")]),r._v(" "),t("ol",[t("li",[r._v("首先，瞬发5个异步请求，我们就得到了并发的5个异步请求"),t("br")]),r._v(" "),t("li",[r._v("等每个异步请求执行完，执行下一个任务"),t("br")]),r._v(" "),t("li",[r._v("等任务所有的项迭代完之后的回调"),t("br")])]),r._v(" "),t("h2",{attrs:{id:"九-前端实现异步的方式有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#九-前端实现异步的方式有哪些"}},[r._v("#")]),r._v(" 九，前端实现异步的方式有哪些?")]),r._v(" "),t("ol",[t("li",[r._v("setTimeout"),t("br")]),r._v(" "),t("li",[r._v("promise"),t("br")]),r._v(" "),t("li",[r._v("generator"),t("br")]),r._v(" "),t("li",[r._v("async await"),t("br")])]),r._v(" "),t("h2",{attrs:{id:"十-事件循环event-loop"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#十-事件循环event-loop"}},[r._v("#")]),r._v(" 十，事件循环event loop")]),r._v(" "),t("ol",[t("li",[r._v("宏任务 "),t("br")]),r._v(" "),t("li",[r._v("微任务 "),t("br")]),r._v(" "),t("li",[r._v("事件的执行顺序，是先执行宏任务，然后执行微任务 "),t("br")])]),r._v(" "),t("h2",{attrs:{id:"十一-递归和尾递归的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#十一-递归和尾递归的区别"}},[r._v("#")]),r._v(" 十一，递归和尾递归的区别")]),r._v(" "),t("h2",{attrs:{id:"十二-vue性能优化有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#十二-vue性能优化有哪些"}},[r._v("#")]),r._v(" 十二，vue性能优化有哪些")]),r._v(" "),t("p",[t("strong",[r._v("定位Vue应用性能问题")])]),r._v(" "),t("ol",[t("li",[r._v("第一部分:运行时性能问题"),t("br")]),r._v(" "),t("li",[r._v("第二部分:加载性能问题"),t("br")])]),r._v(" "),t("p",[t("strong",[r._v("工具")])]),r._v(" "),t("ol",[t("li",[r._v("Chrome Devtool"),t("br")]),r._v(" "),t("li",[r._v("通过Performance工具可录制一段时间的CPU、内存占用、FPS等运行时性能问题"),t("br")]),r._v(" "),t("li",[r._v("通过Network工具可以用来分析加载性能问题"),t("br")])]),r._v(" "),t("p",[t("strong",[r._v("vue应用运行时性能优化建议")])]),r._v(" "),t("ol",[t("li",[r._v("引入生产环境的Vue文件"),t("br")]),r._v(" "),t("li",[r._v("使用单文件组件预编译模板"),t("br")]),r._v(" "),t("li",[r._v("提取组件的CSS到单独的文件"),t("br")]),r._v(" "),t("li",[r._v("利用Obejct.freeze()提升性能"),t("br"),r._v("\nA. 0bject.freeze可以冻结一个对象，冻结之后不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。该方法返回被冻结的对象 "),t("br")]),r._v(" "),t("li",[r._v("扁平化Store数据结构 "),t("br"),r._v("\nA. 可以使用Normalizr将深层嵌套的JSON对象通过定义好的schema转变成使用id作为字典的实体表示的对象 "),t("br")]),r._v(" "),t("li",[r._v("避免持久化Store数据带来的性能问题 "),t("br"),r._v("\nA.持久化写入数据的性能问题"),t("br"),r._v("\n     Vue社区中用的vuex-persitedastate,利用了store的 subscribe机制，来订阅Store数据的 mutation，如果发生了变化，就会写入storage中，默认用的是 localstorage 作为持久化存储。"),t("br"),r._v("\nB.尽量减少直接写入Storage的频率"),t("br"),r._v("\n     i.多次写入操作合并为一次，比如采用函数节流或者将数据先缓存在内存中，最后再一并写入"),t("br"),r._v("\n     ii.只有在必要的时候才写入，比如只有关心的模块的数据发生变化的饿时候才写入"),t("br"),r._v("\nC.避免持久化存储的容量持续增长"),t("br"),r._v("\n     因为localStorage的缓存在某些浏览器中只有5M,设计了一套持久化的数据缓存策略的时候，同时应该设计旧数据的缓存清除策略。"),t("br")]),r._v(" "),t("li",[r._v("优化无限列表性能 "),t("br"),r._v("\nA. vue-virtual-scroll-list和vue-virtual-scroller都是解决这类问题的开源项目。你也可以参考Google工程师的文章Complexities of an lfnite scroller来尝试自己实现一个虚拟的滚动列表来优化性能，主要使用到的技术是DOM回收、墓碑元素和滚动锚定 "),t("br")]),r._v(" "),t("li",[r._v("通过组件懒加载优化超长应用内容初始渲染性能 "),t("br")])]),r._v(" "),t("p",[t("strong",[r._v("应用加载性能优化建议")])]),r._v(" "),t("ol",[t("li",[r._v("利用服务器渲染SSR和预渲染来优化加载性能"),t("br")]),r._v(" "),t("li",[r._v("通过组件懒加载优化超长应用内容加载性能"),t("br")])]),r._v(" "),t("h2",{attrs:{id:"十三-vue的diff算法和react的diff算法的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#十三-vue的diff算法和react的diff算法的区别"}},[r._v("#")]),r._v(" 十三，vue的diff算法和react的diff算法的区别")]),r._v(" "),t("p",[t("strong",[r._v("相同点")]),t("br")]),r._v(" "),t("ol",[t("li",[r._v("Vue和React的diff算法，都是不进行跨层级比较，只做同级比较 "),t("br")])]),r._v(" "),t("p",[t("strong",[r._v("不同点")]),t("br")]),r._v(" "),t("ol",[t("li",[r._v("Vue进行diff时，调用patch打补丁函数，一边比较一边给真实DOM打补丁 "),t("br")]),r._v(" "),t("li",[r._v("Vue对比节点，当节点元素类型相同，但是className不同时，认为是不同类型的元素，删除重新创建，而react责任为同类型节点，进行修改操作 "),t("br")]),r._v(" "),t("li",[r._v("Vue列表对比，采用两端到中间的方式，旧集合和新集合两端各存在两个指针，两两进行比较，如果匹配上就按照新集合去调整旧集合，每次对比结束后，指针向队列中间移动,而react则是从左到右依次对比，利用元素的index和标识lastlndex进行比较，如果满足index < lastndex就移动元素，删除和添加则各自按照规则调整 "),t("br")]),r._v(" "),t("li",[r._v("当一个集合把最后一个节点移动到最前面，react会把前面的节点依次向后移动，而vue只会把最后一个节点放在最前面，这样的操作来看，vue的diff算法是高于react的 "),t("br")])]),r._v(" "),t("h2",{attrs:{id:"十四-vuex-redux的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#十四-vuex-redux的区别"}},[r._v("#")]),r._v(" 十四，vuex redux的区别")]),r._v(" "),t("p",[t("strong",[r._v("流向不同")])]),r._v(" "),t("p",[t("strong",[r._v("Vue")])]),r._v(" "),t("ol",[t("li",[r._v("同步:  view -> commit -> mutations -> state变化 -> view变化"),t("br")]),r._v(" "),t("li",[r._v("异步:  view -> dispatch -> actions -> mutations -> state变化 -> view变化"),t("br")])]),r._v(" "),t("p",[t("strong",[r._v("Redux")])]),r._v(" "),t("ol",[t("li",[r._v("view -> actions -> reducer -> state变化 -> view变化(t)"),t("br")])])])}),[],!1,null,null,null);v.default=_.exports}}]);