(window.webpackJsonp=window.webpackJsonp||[]).push([[244],{6160:function(s,e,l){"use strict";l.r(e);var a=l(15),v=Object(a.a)({},(function(){var s=this,e=s.$createElement,l=s._self._c||e;return l("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[l("h2",{attrs:{id:"_1-打包css"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_1-打包css"}},[s._v("#")]),s._v(" 1. 打包CSS")]),s._v(" "),l("p",[l("strong",[s._v("打包非JS文件，我们需要安装一个loader来处理此文件")])]),s._v(" "),l("ul",[l("li",[s._v("打包css时，可以将css文件也看成是一个模块，我们是通过import来加载这个模块的")]),s._v(" "),l("li",[s._v("在加载这个模块时，webpack其实并不知道如何对其进行加载，我们必须制定对应的loader来完成这个功能")]),s._v(" "),l("li",[s._v("loader 可以用于对模块的源代码进行转换，对于加载css文件来说，我们需要一个可以读取css文件的loader")]),s._v(" "),l("li",[s._v("使用css-loader来读取css文件，安装：npm install css-loader -D")])]),s._v(" "),l("p",[l("strong",[s._v("css-loader的使用方案")])]),s._v(" "),l("ul",[l("li",[s._v("内联方式（了解），使用较少，不方便管理\n"),l("ul",[l("li",[s._v("在引入的样式前加上使用的loader，并且使用!分割；")]),s._v(" "),l("li",[s._v('import "css-loader!../css/out.css"')])])]),s._v(" "),l("li",[s._v("配置方式(重点掌握)")])]),s._v(" "),l("p",[l("strong",[s._v("loader配置")])]),s._v(" "),l("ul",[l("li",[s._v("module.rules中允许我们配置多个loader")]),s._v(" "),l("li",[s._v("配置形式管理loader，方便后期的维护，同时也让你对各个Loader有一个全局的概览")]),s._v(" "),l("li",[s._v("test属性：用于对 resource（资源）进行匹配的，通常会设置成正则表达式")]),s._v(" "),l("li",[s._v("use属性：对应的值时一个数组")]),s._v(" "),l("li",[s._v("use: [ 'css-loader' ]）是 loader 属性的简写方式（如：use: [ { loader: 'css-loader'} ]")])]),s._v(" "),l("p",[l("strong",[s._v("认识style-loader")])]),s._v(" "),l("p",[s._v("通过css-loader来加载css文件了, 但是发现这个css在我们的代码中并没有生效（页面没有效果），因为css-loader只是负责将.css文件进行解析，并不会将解析之后的css插入到页面中，我们希望再完成插入style的操作，那么我们还需要另外一个loader，就是style-loader")]),s._v(" "),l("ul",[l("li",[s._v("安装style-loader   npm install style-loader -D")])]),s._v(" "),l("p",[l("strong",[s._v("配置style-loader")])]),s._v(" "),l("ul",[l("li",[s._v("在配置文件中，添加style-loader")]),s._v(" "),l("li",[s._v("因为loader的执行顺序是从右向左（或者说从下到上，或者说从后到前的），所以我们需要将style-loader写到css-loader的前面")]),s._v(" "),l("li",[s._v("重新执行编译npm run build，可以发现打包后的css已经生效了")])]),s._v(" "),l("h2",{attrs:{id:"_2-打包less"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_2-打包less"}},[s._v("#")]),s._v(" 2. 打包Less")]),s._v(" "),l("p",[s._v("在我们开发中，我们可能会使用less、sass、stylus的预处理器来编写css样式，效率会更高")]),s._v(" "),l("p",[l("strong",[s._v("less-loader处理 less文件")])]),s._v(" "),l("ul",[l("li",[s._v("less-loader需要使用less工具来转化less")]),s._v(" "),l("li",[s._v("安装：npm i less less-loader -D")]),s._v(" "),l("li",[s._v("使用less-loader，来自动使用less工具转换less到css")])]),s._v(" "),l("h2",{attrs:{id:"_3-postcss工具"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_3-postcss工具"}},[s._v("#")]),s._v(" 3. PostCSS工具")]),s._v(" "),l("p",[l("strong",[s._v("什么是PostCSS呢")])]),s._v(" "),l("ul",[l("li",[s._v("PostCSS是一个通过JavaScript来转换样式的工具")]),s._v(" "),l("li",[s._v("这个工具可以帮助我们进行一些CSS的转换和适配，比如自动添加浏览器前缀、css样式的重置")]),s._v(" "),l("li",[s._v("实现这些功能，我们需要借助于PostCSS对应的插件")])]),s._v(" "),l("p",[l("strong",[s._v("使用PostCSS")])]),s._v(" "),l("ul",[l("li",[s._v("第一步：查找PostCSS在构建工具中的扩展，比如webpack中的postcss-loader")]),s._v(" "),l("li",[s._v("第二步：选择可以添加你需要的PostCSS相关的插件")])]),s._v(" "),l("p",[l("strong",[s._v("在webpack中使用postcss就是使用postcss-loader来处理的")])]),s._v(" "),l("ul",[l("li",[s._v("安装postcss-loader    npm install postcss-loader -D")]),s._v(" "),l("li",[s._v("修改加载css的loader，postcss需要有对应的插件才会起效果，所以我们需要配置它的plugin")]),s._v(" "),l("li",[s._v("安装添加前缀的插件  npm install autoprefixer -D")])]),s._v(" "),l("p",[l("strong",[s._v("单独配置文件管理")])]),s._v(" "),l("ul",[l("li",[s._v("在根目录下创建postcss.config.js")]),s._v(" "),l("li",[s._v("将这些配置信息放到一个单独的文件中进行管理")])]),s._v(" "),l("p",[l("strong",[s._v("postcss-preset-env")])]),s._v(" "),l("ul",[l("li",[s._v("在配置postcss-loader时，我们配置插件并不需要使用autoprefixer")]),s._v(" "),l("li",[s._v("postcss-preset-env也是一个postcss的插件，将一些现代的CSS特性，转成大多数浏览器认识的CSS，并且会根据目标浏览器或者运行时环境添加所需的polyfill")]),s._v(" "),l("li",[s._v("会自动帮助我们添加autoprefixer（所以相当于已经内置了autoprefixer）")]),s._v(" "),l("li",[s._v("安装：npm install postcss-preset-env -D")])]),s._v(" "),l("h2",{attrs:{id:"_4-打包图片"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_4-打包图片"}},[s._v("#")]),s._v(" 4. 打包图片")]),s._v(" "),l("ul",[l("li",[s._v("在webpack5之前，加载这些资源我们需要使用一些loader，比如raw-loader 、url-loader、file-loader")]),s._v(" "),l("li",[s._v("在webpack5开始，我们可以直接使用资源模块类型（asset module type），来替代上面的这些loader")])]),s._v(" "),l("p",[l("strong",[s._v("资源模块类型(asset module type)，通过添加 4 种新的模块类型，来替换所有这些 loader")])]),s._v(" "),l("ul",[l("li",[s._v("asset/resource 发送一个单独的文件并导出 URL，之前通过使用 file-loader 实现；")]),s._v(" "),l("li",[s._v("asset/inline 导出一个资源的 data URI，之前通过使用 url-loader 实现；")]),s._v(" "),l("li",[s._v("asset/source 导出资源的源代码，之前通过使用 raw-loader 实现")]),s._v(" "),l("li",[s._v("asset 在导出一个 data URI 和发送一个单独的文件之间自动选择，之前通过使用 url-loader，并且配置资源体积限制实现")])]),s._v(" "),l("p",[l("strong",[s._v("asset module type的使用")])]),s._v(" "),l("ul",[l("li",[s._v("加载图片，我们可以使用下面的方式：")])]),s._v(" "),l("div",{staticClass:"language-js line-numbers-mode"},[l("pre",{pre:!0,attrs:{class:"language-js"}},[l("code",[l("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),l("span",{pre:!0,attrs:{class:"token literal-property property"}},[s._v("test")]),l("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),l("span",{pre:!0,attrs:{class:"token regex"}},[l("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[s._v("/")]),l("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[s._v("\\.(png|svg|jpg|jpeg|gif)$")]),l("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[s._v("/")]),l("span",{pre:!0,attrs:{class:"token regex-flags"}},[s._v("i")])]),l("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n    "),l("span",{pre:!0,attrs:{class:"token literal-property property"}},[s._v("type")]),l("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),l("span",{pre:!0,attrs:{class:"token string"}},[s._v('"asset/resource"')]),s._v("\n"),l("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),l("div",{staticClass:"line-numbers-wrapper"},[l("span",{staticClass:"line-number"},[s._v("1")]),l("br"),l("span",{staticClass:"line-number"},[s._v("2")]),l("br"),l("span",{staticClass:"line-number"},[s._v("3")]),l("br"),l("span",{staticClass:"line-number"},[s._v("4")]),l("br")])]),l("p",[l("strong",[s._v("自定义文件的输出路径和文件名")])]),s._v(" "),l("ul",[l("li",[s._v("方式一：修改output，添加assetModuleFilename属性；")]),s._v(" "),l("li",[s._v("方式二：在Rule中，添加一个generator属性，并且设置filename；")])]),s._v(" "),l("p",[l("strong",[s._v("最常用的placeholder")])]),s._v(" "),l("ul",[l("li",[s._v("[ext]： 处理文件的扩展名")]),s._v(" "),l("li",[s._v("[name]：处理文件的名称；")]),s._v(" "),l("li",[s._v("[hash]：文件的内容，使用MD4的散列函数处理，生成的一个128位的hash值（32个十六进制）")])]),s._v(" "),l("h2",{attrs:{id:"_5-资源模块类型的limit"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_5-资源模块类型的limit"}},[s._v("#")]),s._v(" 5. 资源模块类型的limit")]),s._v(" "),l("p",[l("strong",[s._v("开发中将小的图片进行转换，大的图片直接使用图片")])]),s._v(" "),l("ul",[l("li",[s._v("因为小的图片转换base64之后可以和页面一起被请求，减少不必要的请求过程；")]),s._v(" "),l("li",[s._v("大的图片也进行转换，反而会影响页面的请求速度")])]),s._v(" "),l("p",[l("strong",[s._v("实现步骤")])]),s._v(" "),l("ul",[l("li",[s._v("步骤一：将type修改为asset；")]),s._v(" "),l("li",[s._v("步骤二：添加一个parser属性，并且制定dataUrl的条件，添加maxSize属性；")])]),s._v(" "),l("h2",{attrs:{id:"_6-babel打包js高级语法"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_6-babel打包js高级语法"}},[s._v("#")]),s._v(" 6. babel打包JS高级语法")]),s._v(" "),l("ul",[l("li",[s._v("开发中，我们想要使用ES6+的语法，想要使用TypeScript，开发React项目，它们都是离不开Babel的；")]),s._v(" "),l("li",[s._v("学习Babel对于我们前端开发来说，非常重要")])]),s._v(" "),l("p",[l("strong",[s._v("Babel到底是什么")])]),s._v(" "),l("ul",[l("li",[s._v("Babel是一个工具链，主要用于旧浏览器或者环境中将ECMAScript 2015+代码转换为向后兼容版本的JavaScript；")]),s._v(" "),l("li",[s._v("包括：语法转换、源代码转换等；")])]),s._v(" "),l("p",[l("strong",[s._v("Babel命令行使用")])]),s._v(" "),l("ul",[l("li",[s._v("babel本身可以作为一个独立的工具（和postcss一样），可以单独使用")]),s._v(" "),l("li",[s._v("在命令行尝试使用babel，需要安装如下库")]),s._v(" "),l("li",[s._v("@babel/core：babel的核心代码，必须安装， @babel/cli：可以让我们在命令行使用babel")]),s._v(" "),l("li",[s._v("npm install @babel/cli @babel/core -D")]),s._v(" "),l("li",[s._v("使用babel来处理我们的源代码")]),s._v(" "),l("li",[s._v("npx babel src --out-dir dist")])]),s._v(" "),l("p",[l("strong",[s._v("插件的使用")])]),s._v(" "),l("ul",[l("li",[s._v("转换箭头函数，那么我们就可以使用箭头函数转换相关的插件")]),s._v(" "),l("li",[s._v("npm install @babel/plugin-transform-arrow-functions -D")]),s._v(" "),l("li",[s._v("npx babel src --out-dir dist --plugins=@babel/plugin-transform-arrow-functions")])]),s._v(" "),l("p",[l("strong",[s._v("let/const转成var")])]),s._v(" "),l("ul",[l("li",[s._v("使用 plugin-transform-block-scoping 来进行转化")]),s._v(" "),l("li",[s._v("npm install @babel/plugin-transform-block-scoping -D")]),s._v(" "),l("li",[s._v("npx babel src --out-dir dist --plugins=@babel/plugin-transform-block-scoping,@babel/plugin-transform-arrow-functions")])]),s._v(" "),l("p",[l("strong",[s._v("Babel的预设preset")])]),s._v(" "),l("ul",[l("li",[s._v("如果要转换的内容过多，一个个设置是比较麻烦的，我们可以使用预设（preset）")]),s._v(" "),l("li",[s._v("预设说白了，就是插件的集合")]),s._v(" "),l("li",[s._v("安装：npm install @babel/preset-env -D")]),s._v(" "),l("li",[s._v("使用：npx babel src --out-dir dist --presets=@babel/preset-env")])]),s._v(" "),l("p",[l("strong",[s._v("babel-loader")])]),s._v(" "),l("ul",[l("li",[s._v("在实际开发中，我们通常会在构建工具中通过配置babel来对其进行使用的，比如在webpack中")]),s._v(" "),l("li",[s._v("安装依赖：npm install babel-loader -D  （之前已经安装了@babel/core，那么不需要再次安装）")]),s._v(" "),l("li",[s._v("配置规则，在加载js文件时，使用我们的babel")])]),s._v(" "),l("p",[l("strong",[s._v("babel-preset")])]),s._v(" "),l("ul",[l("li",[s._v("一个个去安装使用插件，那么需要手动来管理大量的babel插件，我们可以直接给webpack提供一个preset，webpack会根据我们的预设来加载对应的插件列表，并且将其传递给babel。")]),s._v(" "),l("li",[s._v("常见的预设有三个：env，react，TypeScript")]),s._v(" "),l("li",[s._v("安装preset-env：npm install @babel/preset-env")])]),s._v(" "),l("h2",{attrs:{id:"_7-打包vue代码"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_7-打包vue代码"}},[s._v("#")]),s._v(" 7. 打包vue代码")]),s._v(" "),l("p",[l("strong",[s._v("要使用vue，需要安装vue")])]),s._v(" "),l("ul",[l("li",[s._v("npm i vue@next")])]),s._v(" "),l("p",[l("strong",[s._v("安装vue-loader， @vue/compiler-sfc")])]),s._v(" "),l("ul",[l("li",[s._v("npm i vue-loader")]),s._v(" "),l("li",[s._v("npm i @vue/compiler-sfc")])])])}),[],!1,null,null,null);e.default=v.exports}}]);