(window.webpackJsonp=window.webpackJsonp||[]).push([[270],{6194:function(n,s,a){"use strict";a.r(s);var t=a(15),e=Object(t.a)({},(function(){var n=this,s=n.$createElement,a=n._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h2",{attrs:{id:"_1-为什么要用typescript-你认为用typescript的好处在哪"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-为什么要用typescript-你认为用typescript的好处在哪"}},[n._v("#")]),n._v(" 1. 为什么要用TypeScript,你认为用TypeScript的好处在哪?")]),n._v(" "),a("hr"),n._v(" "),a("div",{staticClass:"language-text line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("TypeScript的好处：\n    TypeScript增加了代码的可读性和可维护性\n    TypeScript非常包容\n    TypeScript拥有活跃的社区\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br")])]),a("h2",{attrs:{id:"_2-typescript-中-const-和-readonly-的区别-枚举和常量枚举的区别-接口和类型别名的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-typescript-中-const-和-readonly-的区别-枚举和常量枚举的区别-接口和类型别名的区别"}},[n._v("#")]),n._v(" 2. TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？")]),n._v(" "),a("hr"),n._v(" "),a("div",{staticClass:"language-text line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const 和 readonly: \n    const可以防止变量的值被修改，readonly可以防止变量的属性被修改。\n\n枚举和常量枚举: \n    常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。\n\n接口和类型别名: 两者都可以用来描述对象或函数的类型。与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组。\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br")])]),a("h2",{attrs:{id:"_3-any和unknown"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-any和unknown"}},[n._v("#")]),n._v(" 3. any和unknown")]),n._v(" "),a("hr"),n._v(" "),a("div",{staticClass:"language-text line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("any 类型，则允许被赋值为任意类型。使用 any 类型，可以很容易地编写类型正确但在运行时有问题的代码。如果我们使用 any 类型，就无法使用 TypeScript 提供的大量的保护机制。请记住，any 是魔鬼！尽量不要用any。为了解决 any 带来的问题，TypeScript 3.0 引入了 unknown 类型。\n\nunknown与any的最大区别是： 任何类型的值可以赋值给any，同时any类型的值也可以赋值给任何型。unknown 任何类型的值都可以赋值给它，但它只能赋值给unknown和any。\n\n这种机制起到了很强的预防性，更安全，这就要求我们必须缩小类型，我们可以使用typeof、类型断言等方式来缩小未知范围\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br")])])])}),[],!1,null,null,null);s.default=e.exports}}]);